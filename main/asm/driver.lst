0001   0000             ; SYSINFO81 
0002   0000             ; 	GPL
0003   0000             ; 	Oliver Lange
0004   0000             ; 	Version 1.0.1
0005   0000             
0006   0000             ; Compile with "tasm -80 -b wspdrv.asm wspdrv.p" 
0007   0000             
0008   0000             
0009   0000             ; driver for wespi
0010   0000             ;
0011   0000             
0012   0000             
0013   0000              
0014   0000             #define db .byte ;  cross-assembler definitions 
0015   0000             #define dw .word 
0016   0000             #define ds .block 
0017   0000             #define org .org 
0018   0000             #define end .end 
0019   0000             
0020   0000             
0021   0000             
0022   0000             #define ADDR_DISABLE 0
0023   0000             #define UPDATE	01FCh	; LOAD/SAVE adress update subroutine in ROM
0024   0000             
0025   0000             ;;#define VERBOSE 1
0026   0000              
0027   4009             org     $4009 ; BASIC PROGRAMM
0028   4009             ;= System variables ============================================ 
0029   4009              
0030   4009 00             db 0     	;VERSN 
0031   400A 00 00          dw 0     	;E_PPC 
0032   400C A7 45          dw dfile      ;D_FILE 
0033   400E A8 45          dw dfile+1    ;DF_CC 
0034   4010 C2 45          dw var   	;VARS 
0035   4012 00 00          dw 0     	;DEST 
0036   4014 C3 45          dw var+1      ;E_LINE 
0037   4016 C2 45          dw last-1     ;c_ADD 
0038   4018 00 00          dw 0     	;X_PTR 
0039   401A C3 45          dw last  	;STKBOT 
0040   401C C3 45          dw last  	;STKEND 
0041   401E 00             db 0     	;BERG 
0042   401F 5D 40          dw membot     ;MEM 
0043   4021 00             db 0     ;not used 
0044   4022 02             db 2     ;DF_SZ 
0045   4023 01 00          dw 1     ;S_TOP 
0046   4025 FF FF FF       db $FF,$FF,$FF     ;LAST_K 
0047   4028 37             db 55    ;MARGIN 
0048   4029 90 45          dw line10     ;NXTLIN   line10   dfile
0049   402B 00 00          dw 0     ;OLDPPC 
0050   402D 00             db 0     ;FLAGX 
0051   402E 00 00          dw 0     ;STRLEN 
0052   4030 8D 0C          dw $0C8D      ;T_ADDR 
0053   4032 00 00          dw 0     ;SEED 
0054   4034 FF FF          dw $FFFF      ;FRAMES 
0055   4036 00 00          db 0,0   ;COORDS 
0056   4038 BC             db $BC   ;PR_CC 
0057   4039 21 18          db 33,24      ;S_POSN 
0058   403B 40             db 01000000B  ;CDFLAG 
0059   403C                ds 33    ;Print buffer --- now used for loader code, all loaded programs need to have the same !
0060   405D             
0061   405D             membot: 
0062   405D                ds 30    ;Calculator�s memory area 
0063   407B                ds 2     ;not used 
0064   407D              
0065   407D             ;= First BASIC line, asm code ================================== 
0066   407D              
0067   407D             line0: 
0068   407D 00 00          db 0,0   ;line number 
0069   407F 0F 05          dw line10-$-2 ;line length 
0070   4081 EA             db $ea   ; REM 
0071   4082             
0072   4082             
0073   4082             #define ELINE	4014h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0074   4082             #define ELINEHI	4015h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0075   4082             
0076   4082             #define SHOW	0207h  ; ROM-Routinen
0077   4082             #define FAST	02E7h
0078   4082             #define RCLS	0A2Ah
0079   4082             #define GETKEY	02BBh
0080   4082             
0081   4082             
0082   4082             #DEFINE RST_PRTCHAR RST 10H
0083   4082             #DEFINE c_SPACE 0
0084   4082             #DEFINE c_NEWLINE 76H
0085   4082             #DEFINE c_0 1CH
0086   4082             
0087   4082             #DEFINE c_A 26H
0088   4082             #DEFINE c_B c_A+1
0089   4082             #DEFINE c_C c_A+2
0090   4082             #DEFINE c_D c_A+3
0091   4082             #DEFINE c_E c_A+4
0092   4082             #DEFINE c_F c_A+5
0093   4082             #DEFINE c_G c_A+6
0094   4082             #DEFINE c_H c_A+7
0095   4082             #DEFINE c_I c_A+8
0096   4082             #DEFINE c_J c_A+9
0097   4082             #DEFINE c_K c_J+1
0098   4082             #DEFINE c_L c_J+2
0099   4082             #DEFINE c_M c_J+3
0100   4082             #DEFINE c_N c_J+4
0101   4082             #DEFINE c_O c_J+5
0102   4082             #DEFINE c_P c_J+6
0103   4082             #DEFINE c_Q c_J+7
0104   4082             #DEFINE c_R c_J+8
0105   4082             #DEFINE c_S c_J+9
0106   4082             #DEFINE c_T c_S+1
0107   4082             #DEFINE c_U c_S+2
0108   4082             #DEFINE c_V c_S+3
0109   4082             #DEFINE c_W c_S+4
0110   4082             #DEFINE c_X c_S+5
0111   4082             #DEFINE c_Y c_S+6
0112   4082             #DEFINE c_Z c_S+7
0113   4082             
0114   4082             #define UFM_ERRNO 16434 ; Definiert in UFM, Fehlercode 1 Byte (eigentlich SEED)
0115   4082             #define UFM_CMDBUF 16444 ; Definiert in UFM, 32 Byte, alternative Kommando�bergabe (eigentlich PRBUF)
0116   4082             #define UFM_COORDS 16438 ; L�ngen�bergabe 2 Byte (eigentlich COORDS)
0117   4082             
0118   4082             
0119   4082             ;
0120   4082             ;   === Main entry point ====
0121   4082             ;
0122   4082             DRIVER_START:
0123   4082             BASIC_START:
0124   4082             AA45:
0125   4082 CD C8 44    	CALL NAME	; get command line arg
0126   4085 18 1B       	JR BASIC_CONT
0127   4087 00          	NOP
0128   4088 00          	NOP
0129   4089 00          	NOP
0130   408A             
0131   408A             CALL_START:	; (IN UFM als START_ADDR+6 festgelegt)
0132   408A 21 3C 40    	LD HL,UFM_CMDBUF
0133   408D E5              PUSH HL
0134   408E                 ;  get length in BC by parsing for '"' or so..
0135   408E 01 00 00        LD   BC,0
0136   4091             ENDPRSLP:
0137   4091 7E              LD   A,(HL)
0138   4092 FE 0B           CP   11     ; is " ?
0139   4094 28 04           JR   Z, EXITPRSLP
0140   4096 03              INC  BC
0141   4097 23              INC  HL
0142   4098 18 F7           JR   ENDPRSLP
0143   409A             EXITPRSLP:
0144   409A E1              POP  HL ; original pointer
0145   409B             AA44:
0146   409B CD BA 40    	CALL GENER_START
0147   409E 32 32 40    	LD (UFM_ERRNO),A
0148   40A1 C9          	RET
0149   40A2             
0150   40A2             BASIC_CONT:
0151   40A2             AA01:
0152   40A2 CD BA 40    	CALL GENER_START ; A is 0 for ok, !=0 for error
0153   40A5 A7          	AND A
0154   40A6 28 0F       	JR Z,BAS_OK
0155   40A8 3E 2A       	LD A,c_E		; Ausgabe ERR
0156   40AA D7          	RST 10h 
0157   40AB 3E 37       	LD A,c_R
0158   40AD D7          	RST 10h
0159   40AE 3E 37           LD A,c_R
0160   40B0 D7          	RST 10h
0161   40B1 3E 76           LD A,c_NEWLINE
0162   40B3 D7          	RST 10h
0163   40B4                 ; exit
0164   40B4 AF              XOR A
0165   40B5 CF          	RST 08h
0166   40B6 09              db  09h             ; Error Report: Invalid argument
0167   40B7             	;db 0FFh
0168   40B7             
0169   40B7             BAS_OK:
0170   40B7             	; RET  ; TODO check if RET or better RST8 with -1
0171   40B7 AF              XOR A		; sonst zurueck nach BASIC
0172   40B8 CF          	RST 08h
0173   40B9 FF          	db 0FFh
0174   40BA             	
0175   40BA             
0176   40BA             GENER_START: ; Interpreting the string independent of its origin, on ret A=0 for okay, BC retval to basic
0177   40BA 7E          	LD A,(HL)   ; HL=start, BC=length
0178   40BB 23              INC  HL
0179   40BC 0B              DEC  BC
0180   40BD             AA00:
0181   40BD 11 E5 40        LD   DE,GENER_END
0182   40C0 D5              PUSH DE     ; ret adddess
0183   40C1             ;	CP c_I		; Info
0184   40C1             ;	JP Z,INFO1
0185   40C1 FE 38       	CP c_S		; Save
0186   40C3             AA41:
0187   40C3 CA D4 42    	JP Z,SAVE1
0188   40C6 FE 31       	CP c_L		; Load
0189   40C8             AA42:
0190   40C8 CA E0 41    	JP Z,LOAD1
0191   40CB             ;	CP 29h		; ist es ein D;
0192   40CB             ;	JP Z,DIR1
0193   40CB             ;	CP 3Bh		; ist es ein V (UFM)
0194   40CB             ;	JP Z,DIRV1
0195   40CB             ;	CP 30h		; ist es ein K (UFM)
0196   40CB             ;	JP Z,DIRK1
0197   40CB             ;	CP 37h		; ist es ein R
0198   40CB             ;	JP Z,RENAM1
0199   40CB             ;	CP 2Ah		; ist es ein E
0200   40CB             ;	JP Z,ERAS1
0201   40CB FE 2E       	CP c_I		;  I
0202   40CD             AA02:
0203   40CD CA ED 40    	JP Z,INST_RELOC
0204   40D0 FE 39       	CP c_T		; Test, return 0...1023 dependng on number of correct bytes
0205   40D2             AA43:
0206   40D2 CA A8 42    	JP Z,TESTPATTERN
0207   40D5 FE 29       	CP c_D		; Directory
0208   40D7             AA52:
0209   40D7 CA E0 41    	JP Z,LOAD1
0210   40DA FE 2D       	CP c_H		; Help
0211   40DC             AA03:
0212   40DC CA F2 43    	JP Z,HLP
0213   40DF FE 0F       	CP 0Fh		; ist es ein ?
0214   40E1             AA04:
0215   40E1 CA F2 43    	JP Z,HLP
0216   40E4 C9              ret 
0217   40E5             
0218   40E5             GENER_END:
0219   40E5 F5              PUSH AF ; holds our error status
0220   40E6 C5              PUSH BC ; ret value...
0221   40E7 CD 07 02    	CALL SHOW
0222   40EA C1              POP  BC
0223   40EB F1              POP  AF
0224   40EC C9          	RET
0225   40ED             	
0226   40ED             INST_RELOC:
0227   40ED                 ; address with new memory location follows. Cpoies the driver and corrects the absolute adresses accordingly
0228   40ED             AA09:
0229   40ED CD 69 42        CALL PARS_DEC_NUM   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0230   40F0 3E 01           LD   A,1
0231   40F2 C0              RET  NZ
0232   40F3 D5              PUSH DE
0233   40F4 CD E7 02    	CALL FAST	; go to fast mode so we can use index regs
0234   40F7 D1              POP  DE
0235   40F8 DD E5           PUSH IX     ; save IX till end
0236   40FA D5              PUSH DE
0237   40FB DD E1           POP  IX     ; new start addr in IX, will need it quite often
0238   40FD                 ; copy RAW driver
0239   40FD             AA06:
0240   40FD 21 82 40        LD HL,DRIVER_START
0241   4100 01 0D 05        LD BC,DRIVER_END-DRIVER_START
0242   4103 ED B0           LDIR
0243   4105                 ; correct abs addr occurrences, all in this table:
0244   4105             AA07:
0245   4105 21 4C 41        LD HL, RELOC_TABLE
0246   4108             RLCLOOP:
0247   4108 5E              LD   E,(HL)
0248   4109 23              INC  HL
0249   410A 56              LD   D,(HL)
0250   410B 23              INC  HL
0251   410C 7A              LD   A,D
0252   410D B3              OR  E
0253   410E 28 1C           JR   Z, ENDRLCCP    ; null end marker
0254   4110 E5              PUSH HL ; next RELOC_TABLE pos
0255   4111                 ; DE is position of the addr tag relative to start
0256   4111 DD E5           PUSH IX
0257   4113 E1              POP  HL
0258   4114 19              ADD  HL,DE
0259   4115                 ; HL is the absolute label pos to modify
0260   4115 E5              PUSH HL ; need it later to write
0261   4116 5E              LD   E,(HL) 
0262   4117 23              INC  HL
0263   4118 56              LD   D,(HL)
0264   4119             AA05:
0265   4119 21 82 40        LD   HL, DRIVER_START
0266   411C EB              EX   DE,HL
0267   411D A7          	AND A		; clear carry
0268   411E ED 52       	SBC HL,DE	; actual address minus old offset
0269   4120             
0270   4120                 ; HL is relative addr
0271   4120 DD E5           PUSH IX
0272   4122 D1              POP  DE
0273   4123 19              ADD  HL,DE  ; add new offset
0274   4124 EB              EX   DE,HL
0275   4125                 ; DE is new abs addr
0276   4125 E1              POP  HL
0277   4126 73              LD   (HL),E
0278   4127 23              INC  HL
0279   4128 72              LD   (HL),D
0280   4129 E1              POP HL ; restore RELOC_TABLE pos
0281   412A 18 DC           JR RLCLOOP
0282   412C             ENDRLCCP:
0283   412C DD E1           POP  IX
0284   412E AF              XOR  A
0285   412F 01 0D 05        LD   BC,DRIVER_END-DRIVER_START
0286   4132 C9              RET
0287   4133              
0288   4133             
0289   4133             PRINTHEX:
0290   4133 F5          	PUSH AF
0291   4134 E5          	PUSH HL
0292   4135 C5          	PUSH BC
0293   4136 4F          	LD C,A		; SAVE
0294   4137 CB 3F       	SRL A
0295   4139 CB 3F       	SRL A
0296   413B CB 3F       	SRL A
0297   413D CB 3F       	SRL A
0298   413F C6 1C       	ADD A,1CH	; Offset to '0'
0299   4141 D7          	RST 10H
0300   4142 79          	LD A,C
0301   4143 E6 0F       	AND	0FH		; MASK
0302   4145 C6 1C       	ADD A,1CH	; Offset to '0'
0303   4147 D7          	RST 10H
0304   4148 C1          	POP BC
0305   4149 E1          	POP HL
0306   414A F1          	POP AF
0307   414B C9          	RET
0308   414C             
0309   414C             
0310   414C             RELOC_TABLE:
0311   414C              ;   dw 0
0312   414C 3C 00           dw AA00+1-DRIVER_START
0313   414E 21 00           dw AA01+1-DRIVER_START
0314   4150 4C 00           dw AA02+1-DRIVER_START
0315   4152 5B 00           dw AA03+1-DRIVER_START
0316   4154 60 00           dw AA04+1-DRIVER_START
0317   4156 98 00           dw AA05+1-DRIVER_START
0318   4158 7C 00           dw AA06+1-DRIVER_START
0319   415A 84 00           dw AA07+1-DRIVER_START
0320   415C 71 03           dw AA08+1-DRIVER_START
0321   415E 6C 00           dw AA09+1-DRIVER_START
0322   4160             
0323   4160 63 01           dw AA10+1-DRIVER_START
0324   4162 70 01           dw AA11+1-DRIVER_START
0325   4164 73 01           dw AA12+1-DRIVER_START
0326   4166 7F 01           dw AA13+1-DRIVER_START
0327   4168 88 01           dw AA14+1-DRIVER_START
0328   416A 9B 01           dw AA15+1-DRIVER_START
0329   416C A5 01           dw AA16+1-DRIVER_START
0330   416E C2 01           dw AA17+1-DRIVER_START
0331   4170 29 02           dw AA18+1-DRIVER_START
0332   4172 34 02           dw AA19+1-DRIVER_START
0333   4174             
0334   4174 3D 02           dw AA20+1-DRIVER_START
0335   4176 55 02           dw AA21+1-DRIVER_START
0336   4178 5F 02           dw AA22+1-DRIVER_START
0337   417A 74 02           dw AA23+1-DRIVER_START
0338   417C 7E 02           dw AA24+1-DRIVER_START
0339   417E 8C 02           dw AA25+1-DRIVER_START
0340   4180 9A 02           dw AA26+1-DRIVER_START
0341   4182 9D 02           dw AA27+1-DRIVER_START
0342   4184 A9 02           dw AA28+1-DRIVER_START
0343   4186 B1 02           dw AA29+1-DRIVER_START
0344   4188             
0345   4188 DE 03           dw AA30+1-DRIVER_START
0346   418A E8 03           dw AA31+1-DRIVER_START
0347   418C 1A 04           dw AA32+1-DRIVER_START
0348   418E 1D 04           dw AA33+1-DRIVER_START
0349   4190 27 04           dw AA34+1-DRIVER_START
0350   4192 75 04           dw AA35+1-DRIVER_START
0351   4194 81 04           dw AA36+1-DRIVER_START
0352   4196 8D 04           dw AA37+1-DRIVER_START
0353   4198 99 04           dw AA38+1-DRIVER_START
0354   419A A5 04           dw AA39+1-DRIVER_START
0355   419C             
0356   419C B1 04           dw AA40+1-DRIVER_START
0357   419E 42 00           dw AA41+1-DRIVER_START
0358   41A0 47 00           dw AA42+1-DRIVER_START
0359   41A2 51 00           dw AA43+1-DRIVER_START
0360   41A4 1A 00           dw AA44+1-DRIVER_START
0361   41A6 01 00           dw AA45+1-DRIVER_START
0362   41A8 74 03           dw AA46+1-DRIVER_START
0363   41AA 77 03           dw AA47+1-DRIVER_START
0364   41AC 7A 03           dw AA48+1-DRIVER_START
0365   41AE 7D 03           dw AA49+1-DRIVER_START
0366   41B0             
0367   41B0 80 03           dw AA50+1-DRIVER_START
0368   41B2 86 03           dw AA51+1-DRIVER_START
0369   41B4 56 00           dw AA52+1-DRIVER_START
0370   41B6             
0371   41B6             
0372   41B6 00 00           dw 0    ; final
0373   41B8             
0374   41B8             
0375   41B8             
0376   41B8             CHECKCOMMA:  ; Z is set when comma seperator found in string, NZ if not, uses A
0377   41B8                 ; BC =0?
0378   41B8 AF              XOR  A
0379   41B9 B9              CP   C
0380   41BA 20 02           JR   NZ,CHKK_CONT
0381   41BC 3C              INC  A ; clear the Z flag
0382   41BD C9              RET     ; no match till end
0383   41BE             CHKK_CONT:
0384   41BE 7E              LD   A, (HL)
0385   41BF FE 1A           CP   26     ; comma
0386   41C1 C8              RET  z
0387   41C2 FE 19           CP   25     ; also check for semicolon
0388   41C4 C8              RET  z
0389   41C5 23              INC  HL
0390   41C6 0B              DEC  BC
0391   41C7 18 EF           JR CHECKCOMMA
0392   41C9             
0393   41C9             
0394   41C9             SKIPEMPTY:  ; Z is set when comma seperator found in string, NZ if not, uses A
0395   41C9                 ; BC =0?
0396   41C9 AF              XOR  A
0397   41CA B9              CP   C
0398   41CB 20 05           JR   NZ,CHKE_CONT
0399   41CD B8              CP   B
0400   41CE 20 02           JR   NZ,CHKE_CONT
0401   41D0 3C              INC  A ; clear the Z flag
0402   41D1 C9              RET     ; no match till end
0403   41D2             CHKE_CONT:
0404   41D2 BE              CP   (HL)
0405   41D3 C0              RET  NZ ; not empty,leave
0406   41D4 23              INC  HL
0407   41D5 0B              DEC  BC
0408   41D6 18 F1           JR SKIPEMPTY
0409   41D8             
0410   41D8             PRINTA:
0411   41D8 E5              PUSH HL
0412   41D9 D5              PUSH DE
0413   41DA C5              PUSH BC
0414   41DB D7              RST 10H
0415   41DC C1              POP  BC
0416   41DD D1              POP  DE
0417   41DE E1              POP  HL
0418   41DF C9              RET
0419   41E0                 
0420   41E0             
0421   41E0             LOAD1: ; both load and dir
0422   41E0             	; HL points to arg string, BC number of chars
0423   41E0 2B              DEC HL  ; back to original CMD - as it coulf be LOAD or DIR
0424   41E1 03              INC BC  ; also transmit CMD char here as we need to distinguish L and D
0425   41E2 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0426   41E3 C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0427   41E4                 ; Check if we have contact
0428   41E4             AA10:    
0429   41E4 CD 5F 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0430   41E7 A7              AND A
0431   41E8                 ; Send LOAD request
0432   41E8 C1              POP  BC
0433   41E9 E1              POP  HL ; recover name pointer/length
0434   41EA 28 52           JR   Z, LD_ERR ; NO CONTACT after TRY_HANDSHAKE
0435   41EC E5              PUSH HL  ; and again store for binload
0436   41ED C5              PUSH BC  ; 
0437   41EE             
0438   41EE 41              ld   B,C ; length, assume <256
0439   41EF 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0440   41F1             AA11:
0441   41F1 CD DC 44        CALL SEND_PACKET
0442   41F4             
0443   41F4                 ; now retrieve key, must be 123
0444   41F4             AA12:
0445   41F4 CD AE 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0446   41F7 FE 7B           CP  123
0447   41F9 20 41           JR NZ,LD_ERR2
0448   41FB 06 04           LD   B,4
0449   41FD 7E              LD  A,(HL)  ; dummy for timing
0450   41FE              
0451   41FE             LOADELY1:         ;    //47 delay between the header bytes
0452   41FE 10 FE           DJNZ LOADELY1
0453   4200             
0454   4200                 ; now retrieve length, 0 for error
0455   4200             AA13:
0456   4200 CD AE 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0457   4203 6F              LD   L,A
0458   4204 06 05           LD   B,5
0459   4206             
0460   4206             LOADELY2:         ;    //60 delay between the length bytes
0461   4206 10 FE           DJNZ LOADELY2
0462   4208             
0463   4208 00              NOP
0464   4209             AA14:
0465   4209 CD AE 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0466   420C 67              LD   H,A
0467   420D B5              OR   L
0468   420E 28 2C           JR Z,LD_ERR2
0469   4210 EB              EX   DE,HL
0470   4211                 ; Here we have DE= len
0471   4211                 ; get addr
0472   4211 C1              POP  BC
0473   4212 E1              POP  HL ; recover name pointer/length
0474   4213 D5              PUSH DE             ; length, will go to BC below
0475   4214 D5              PUSH DE             ; length, again, for end result
0476   4215 7E              LD A,(HL) ; check command L or D
0477   4216 FE 29           CP c_D
0478   4218 28 33           JR Z,SHOWDIR
0479   421A 23              INC HL  ; skip cmd
0480   421B 0B              DEC BC
0481   421C                 ;  test if saving binary or regular basic
0482   421C             AA15:
0483   421C CD B8 41        CALL CHECKCOMMA
0484   421F 28 20           JR   Z, BINLOAD
0485   4221             
0486   4221                 ; LOAD BASIC program if not BINLOAD, set addr
0487   4221 21 09 40    	LD HL,4009h		; 
0488   4224 1E 01           LD   E,1        ; mark as basic load
0489   4226             
0490   4226             LOADLOOP:
0491   4226                 ; timing  - 74 between calls seems to be more reliable than 70!
0492   4226             AA16:
0493   4226 CD AE 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0494   4229 77              LD   (HL),A
0495   422A 77              LD   (HL),A ; dummy for timing
0496   422B 23              INC  HL
0497   422C C1              POP  BC     ; get remaining length
0498   422D 0B              DEC  BC
0499   422E 79              LD   A,C
0500   422F B0              OR   B
0501   4230 28 03           JR Z, LD_END
0502   4232 C5              PUSH BC
0503   4233 18 F1           JR  LOADLOOP
0504   4235             LD_END:  
0505   4235 C1              POP  BC ; orig length
0506   4236 AF              XOR  A
0507   4237 BB              CP   E  ; 0 for binary
0508   4238 C8              RET   Z ; normal return for binload with length in BC
0509   4239                 ; end for BASIC loader
0510   4239 D1              POP  DE ; dummy, ret addr
0511   423A CF          	RST 08h ;
0512   423B FF          	db 0FFh
0513   423C             
0514   423C             
0515   423C             LD_ERR2:
0516   423C D1              POP  DE ; dummy
0517   423D D1              POP  DE ; dummy
0518   423E             LD_ERR:
0519   423E 3E 01           LD   A,1
0520   4240 C9              RET ; BC WILL be at maximum now
0521   4241             
0522   4241             
0523   4241             BINLOAD: ; HL points to the comma in arg string, now parse addr, length
0524   4241 23              INC  HL
0525   4242 0D              DEC  C
0526   4243             AA17:
0527   4243 CD 69 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0528   4246 20 F4           JR NZ, LD_ERR2   ; parse error
0529   4248                 ; addr in DE
0530   4248 EB              EX   DE,HL
0531   4249 1E 00           LD   E,0    ; mark as binary
0532   424B 18 D9           JR LOADLOOP
0533   424D             
0534   424D             SHOWDIR:
0535   424D                 ; this is like a binload but into the screen area
0536   424D                 ; first prepare space for it
0537   424D 2A 0C 40        LD HL,(16396) ; D_FILE pos
0538   4250 23              INC HL
0539   4251 22 0E 40        LD (16398),HL  ; restore print position to start of screen as we clean all
0540   4254 EB              EX DE,HL       ; start addr now in DE
0541   4255 2A 10 40        LD HL,(16400)  ; VARS pos as end of screen
0542   4258 2B              DEC HL;        ; leave one byte in there, otherwise pointers will collapse
0543   4259 CD 5D 0A        CALL $A5D      ; reclaim-diff: release mem from DE to HL: CF_CC to VARS-1
0544   425C C1              POP BC         ; get length of new screen
0545   425D C5              PUSH BC        ; put back, needed later 
0546   425E 0B              DEC BC         ; we left one byte already
0547   425F 22 0E 40        LD (16398),HL  ; start from print position
0548   4262 CD 9E 09        CALL $99E      ; make-room: reserve BC bytes at HL
0549   4265 1E 00           LD   E,0       ; from now on it is just a binload, mark
0550   4267 18 BD           JR LOADLOOP    ; 
0551   4269             
0552   4269             
0553   4269             ; parse a decimal number
0554   4269             PARS_DEC_NUM:   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0555   4269 11 00 00    	LD DE, 0
0556   426C AF              XOR  A
0557   426D B9              CP   C
0558   426E 28 35           JR Z,PARSFAIL
0559   4270             
0560   4270             PARS_LLOOP:     ; look for first number
0561   4270 7E          	LD A,(HL)
0562   4271 A7          	AND A
0563   4272 28 29       	JR Z, PARS_SKIPWS ; skip whitespace
0564   4274             PARS_LLP2:
0565   4274 D6 1C       	SUB 01ch	;"0"
0566   4276 38 2D       	JR C,PARSFAIL
0567   4278 FE 0A       	CP 10
0568   427A 30 29       	JR NC,PARSFAIL
0569   427C             	; have a digit in A,
0570   427C E5          	PUSH HL
0571   427D             	; DE times ten
0572   427D 62          	LD H,D      ; now in both HL and DE
0573   427E 6B          	LD L,E
0574   427F 29          	ADD HL,HL
0575   4280 29          	ADD HL,HL
0576   4281 29          	ADD HL,HL ; times 8 so far
0577   4282 19          	ADD HL,DE
0578   4283 19          	ADD HL,DE
0579   4284             	; Add new digit
0580   4284 16 00       	LD D,0
0581   4286 5F          	LD E,A
0582   4287 19          	ADD HL,DE
0583   4288 EB          	EX DE,HL    ; new value of DE
0584   4289 E1          	POP HL  ; pointer to argline back in HL
0585   428A 23          	INC HL
0586   428B 0D          	DEC C
0587   428C 28 15           JR Z,PARSDONE
0588   428E 7E          	LD A,(HL)   ; load next char to see if end
0589   428F FE 1A           CP   26 ;  ','
0590   4291 28 10           JR Z,PARSDONE
0591   4293 FE 0E           CP   14 ;  ';'
0592   4295 28 0C           JR Z,PARSDONE
0593   4297 FE 0B           CP   11 ;  '"'
0594   4299 28 08           JR Z,PARSDONE
0595   429B 18 D7       	JR PARS_LLP2 
0596   429D             PARS_SKIPWS:
0597   429D 23          	INC HL
0598   429E 0D          	DEC C
0599   429F 28 04           JR Z,PARSFAIL
0600   42A1 18 CD       	JR PARS_LLOOP 
0601   42A3             
0602   42A3             PARSDONE:
0603   42A3 AF              XOR  A
0604   42A4 C9          	RET
0605   42A5             PARSFAIL:
0606   42A5 AF              XOR  A
0607   42A6 3C              INC  A
0608   42A7 C9          	RET
0609   42A8             
0610   42A8             
0611   42A8             TESTPATTERN:
0612   42A8             	; HL points to arg string, BC number of chars
0613   42A8 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0614   42A9 C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0615   42AA                 ; Check if we have contact
0616   42AA             AA18:    
0617   42AA CD 5F 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0618   42AD A7              AND A
0619   42AE                 ; Send LOAD request
0620   42AE C1              POP  BC
0621   42AF E1              POP  HL ; recover name pointer/length
0622   42B0 28 1C           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0623   42B2             
0624   42B2 41              ld   B,C ; length, assume <256
0625   42B3 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0626   42B5             AA19:
0627   42B5 CD DC 44        CALL SEND_PACKET
0628   42B8             
0629   42B8                 ; now retrieve 1024 bytes and see how many are correct
0630   42B8                 ; gap between byte calls should be 77+12+7 - 17-10 = 69 clocks
0631   42B8 01 00 00        LD   BC,0
0632   42BB             TESTBLOOP:
0633   42BB C5              PUSH BC
0634   42BC 00              NOP         ; timing adjust 66/70
0635   42BD 00              NOP         ; timing adjust 70/74 - 74 seems to be more reliable than 70!
0636   42BE             AA20:
0637   42BE CD AE 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0638   42C1 C1              POP  BC
0639   42C2 B9              CP   C  ; incomming data in A is 0,1,2,3,4...255,0,1... as byte
0640   42C3 3E 00           LD   A,0 ; not affect flags, test never reports errors to better automatize
0641   42C5 C0              RET  NZ ; report BC at point of first failure
0642   42C6 03              INC  BC
0643   42C7 3E 10           LD   A,16 ; 4kbyte testsize
0644   42C9 B8              CP   B
0645   42CA 20 EF           JR   NZ, TESTBLOOP
0646   42CC AF              XOR  A
0647   42CD C9              RET ; BC WILL be at maximum now
0648   42CE             
0649   42CE             
0650   42CE             
0651   42CE             ERREXIT:
0652   42CE 3E 01           LD   A,1
0653   42D0 01 00 00        LD   BC,0
0654   42D3 C9              RET
0655   42D4             
0656   42D4             SAVE1:
0657   42D4             	; HL points to arg string, BC number of chars
0658   42D4 E5              PUSH HL  ; orig pos of args (w/o prefix S)
0659   42D5 C5              PUSH BC  ; orig lenght of args (w/o prefix S)
0660   42D6             
0661   42D6             
0662   42D6             ;    LD   A, c_S
0663   42D6             ;    CALL PRINTA
0664   42D6             
0665   42D6                 ; Check if we have contact
0666   42D6             AA21:   
0667   42D6 CD 5F 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0668   42D9                 ; Send SAVE request
0669   42D9 C1              POP  BC
0670   42DA E1              POP  HL ; recover name pointer/length
0671   42DB                 ; evauate connect result
0672   42DB A7              AND A
0673   42DC 28 F0           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0674   42DE             
0675   42DE                 ; again store original argument string, will need it now and when sending name
0676   42DE E5              PUSH HL
0677   42DF C5              PUSH BC
0678   42E0             
0679   42E0                 ;  test if saving binary or regular basic
0680   42E0             AA22:
0681   42E0 CD B8 41        CALL CHECKCOMMA
0682   42E3 28 43           JR   Z, BINSAVE
0683   42E5             
0684   42E5                 ; SAVE BASIC program if not BINSAVE, pre-calc addr,size into HL and BC
0685   42E5 11 09 40    	LD DE,4009h		; Get length
0686   42E8 2A 14 40    	LD HL,(ELINE)	
0687   42EB A7          	AND A		; clear carry
0688   42EC ED 52       	SBC HL,DE	; HL=length
0689   42EE 44          	LD B,H
0690   42EF 4D          	LD C,L
0691   42F0 EB          	EX DE,HL	; Now HL=Start, BC=length
0692   42F1             
0693   42F1             SAVE_CONT: ;continue common path of BIN and BASIC save
0694   42F1 D9              EXX     ; store payload addr and length for now
0695   42F2 EB          	EX DE,HL	; HL' must be restored, save in DE'
0696   42F3 C1              POP  BC
0697   42F4 E1              POP  HL ; recover name pointer/length
0698   42F5             AA23:
0699   42F5 CD C9 41        CALL SKIPEMPTY 
0700   42F8 AF              XOR  A
0701   42F9 B9              CP   C
0702   42FA 28 40           JR   Z, ERREXIT3 ; NO NAME
0703   42FC 41              ld   B,C ; length, assume <256
0704   42FD 0E 5B           ld   C,91 ; packet ID ZX_QSAVE_TAG_SAVEPFILE
0705   42FF             AA24:
0706   42FF CD DC 44        CALL SEND_PACKET
0707   4302 EB          	EX DE,HL	; HL' must be restored, was saved in DE'
0708   4303 D9              EXX ; Recover, now HL=Start, BC=length
0709   4304             	
0710   4304             SVSENDFUL:
0711   4304 AF              XOR  A
0712   4305 B8              CP   B
0713   4306 28 0C           JR   Z, SVSENDLAST
0714   4308                 ; send full packets
0715   4308 C5              PUSH BC
0716   4309 06 00           LD   B,0    ; 256 bytes
0717   430B 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0718   430D             AA25:
0719   430D CD DC 44        CALL SEND_PACKET
0720   4310 C1              POP  BC
0721   4311 05              DEC  B
0722   4312 18 F0           JR   SVSENDFUL
0723   4314             
0724   4314             SVSENDLAST:
0725   4314 AF              XOR  A
0726   4315 B9              CP   C
0727   4316 28 06           JR   Z, SVSENDEND
0728   4318 41              LD   B,C ; length
0729   4319 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0730   431B             AA26:
0731   431B CD DC 44        CALL SEND_PACKET
0732   431E             
0733   431E             SVSENDEND:
0734   431E             AA27:
0735   431E CD 94 44        CALL QS_FINAL_ACK   ; Z set for success
0736   4321 20 AB           JR   NZ, ERREXIT
0737   4323 AF              XOR  A
0738   4324 01 01 00        LD   BC, 1
0739   4327 C9          	RET
0740   4328             
0741   4328             
0742   4328             BINSAVE: ; HL points to the comma in arg string, now parse addr, length
0743   4328 23              INC  HL
0744   4329 0D              DEC  C
0745   432A             AA28:
0746   432A CD 69 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0747   432D 20 13           JR NZ, BSERREXIT   ; parse error
0748   432F D5              PUSH DE ; store addr, from now on have to use BSERREXIT2 to stack-unwind here
0749   4330 23              INC  HL
0750   4331 0D              DEC  C
0751   4332             AA29:
0752   4332 CD 69 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0753   4335 20 0A           JR NZ, BSERREXIT2   ; parse error
0754   4337                 ; length in DE
0755   4337                 ; Now put HL=Start, BC=length
0756   4337 42              LD   B,D
0757   4338 4B              LD   C,E
0758   4339 E1              POP  HL
0759   433A 18 B5           JR SAVE_CONT
0760   433C             
0761   433C             ERREXIT3:
0762   433C EB          	EX DE,HL	; HL' must be restored, saved in DE'
0763   433D D9              EXX ; Recover
0764   433E 3E 01           LD   A,1
0765   4340 C9          	RET
0766   4341             
0767   4341             BSERREXIT2:
0768   4341 D1              POP  DE
0769   4342             BSERREXIT:
0770   4342 C1              POP  BC
0771   4343 E1              POP  HL ; recover name pointer/length
0772   4344 3E 01           LD   A,1
0773   4346 C9          	RET
0774   4347             
0775   4347             
0776   4347             HLPTXT1:
0777   4347 3F 3D 00 3C 	db c_Z,c_X,0,c_W,c_E,c_S,c_P,c_I,0,c_D,c_R,c_I,c_V,c_E,c_R,c_NEWLINE
0777   434B 2A 38 35 2E 
0777   434F 00 29 37 2E 
0777   4353 3B 2A 37 76 
0778   4357 76 76           db c_NEWLINE,c_NEWLINE
0779   4359 35 37 2E 33 	db c_P,c_R,c_I,c_N,c_T, 0 , c_U, c_S, c_R, 0 
0779   435D 39 00 3A 38 
0779   4361 37 00 
0780   4363 FF          	db $ff
0781   4364             
0782   4364             ;	db "INFO  ",22h,"I",22h,0dh
0783   4364             ;	db "DIR   ",22h,"D",22h,0dh
0784   4364             ;	db "ERASE ",22h,"ENAME.P",22h,0dh
0785   4364             ;	db "MKDIR ",22h,"DMVERZ",22h,0dh
0786   4364             ;	db "RMDIR ",22h,"DEVERZ",22h,0dh
0787   4364             ;	db "CHDIR ",22h,"DCVERZ",22h,0dh
0788   4364             HLPTXT2:
0789   4364 1A 0B 13 28 	db 26, 11, 19, c_C,c_M,c_D, 18,  11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0789   4368 32 29 12 0B 
0789   436C 76 
0790   436D 76 76           db c_NEWLINE,c_NEWLINE
0791   436F 31 34 26 29 	db c_L,c_O,c_A,c_D, 0 , 0 , 0, 11, c_L, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0791   4373 00 00 00 0B 
0791   4377 31 33 26 32 
0791   437B 2A 0B 76 
0792   437E 38 26 3B 2A 	db c_S,c_A,c_V,c_E, 0 , 0 , 0, 11, c_S, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0792   4382 00 00 00 0B 
0792   4386 38 33 26 32 
0792   438A 2A 0B 76 
0793   438D 27 31 34 26 	db c_B,c_L,c_O,c_A,c_D, 0 , 0, 11, c_L, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 11,c_NEWLINE   ; "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0793   4391 29 00 00 0B 
0793   4395 31 33 26 32 
0793   4399 2A 1A 26 29 
0793   439D 29 37 0B 76 
0794   43A1 27 38 26 3B 	db c_B,c_S,c_A,c_V,c_E, 0 , 0, 11, c_S, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 26, c_L, c_E, c_N,  11,c_NEWLINE   ; "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0794   43A5 2A 00 00 0B 
0794   43A9 38 33 26 32 
0794   43AD 2A 1A 26 29 
0794   43B1 29 37 1A 31 
0794   43B5 2A 33 0B 76 
0795   43B9 2D 2A 31 35 	db c_H,c_E,c_L,c_P, 0 , 0 , 0, 11, c_H, 11,c_NEWLINE   ;  c_H,   "HELP  ",22h,"H",22h,0dh
0795   43BD 00 00 00 0B 
0795   43C1 2D 0B 76 
0796   43C4             ;	db "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0797   43C4             ;	db "RENAME",22h,"ROLDNAME NEWNAME",22h,0dh
0798   43C4 76              db c_NEWLINE
0799   43C5 2E 33 38 39 	db c_I,c_N,c_S,c_T,c_A,c_L,c_L, 0 , c_D,c_R,c_V, 0 ,c_T,c_O, 0, c_R,c_A,c_M,  0, 11, c_I, 0, c_A, c_D, c_D, c_R,  11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0799   43C9 26 31 31 00 
0799   43CD 29 37 3B 00 
0799   43D1 39 34 00 37 
0799   43D5 26 32 00 0B 
0799   43D9 2E 00 26 29 
0799   43DD 29 37 0B 76 
0800   43E1             ;	db c_T,c_E,c_S,c_T, 0 , 0 , 0, 11, c_T, c_L, c_T, c_T, c_T, c_0+2, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0801   43E1             ;	db "FOR SIGGI'S UFM :V/R/K",0dh
0802   43E1 76              db c_NEWLINE
0803   43E2 76              db c_NEWLINE
0804   43E3 37 2A 3B 00     db c_R, c_E, c_V, 0, c_A, c_0+1,0,0,0, c_S, c_I, c_Z, c_E, 0
0804   43E7 26 1D 00 00 
0804   43EB 00 38 2E 3F 
0804   43EF 2A 00 
0805   43F1 FF          	db $ff
0806   43F2             
0807   43F2             
0808   43F2             ; === Subroutine print help text ====
0809   43F2             AA08:
0810   43F2             HLP:
0811   43F2 21 47 43    	LD HL,HLPTXT1
0812   43F5             AA46:
0813   43F5 CD 0F 44        CALL PRINTTEXT
0814   43F8             AA47:
0815   43F8 21 82 40    	LD HL,DRIVER_START
0816   43FB             AA48:
0817   43FB CD 17 44        CALL PRINTBASE10
0818   43FE             AA49:
0819   43FE 21 64 43    	LD HL,HLPTXT2
0820   4401             AA50:
0821   4401 CD 0F 44        CALL PRINTTEXT
0822   4404 21 0D 05        LD HL,DRIVER_END-DRIVER_START
0823   4407             AA51:
0824   4407 CD 17 44        CALL PRINTBASE10
0825   440A 01 2A 00        LD   BC,42
0826   440D AF              XOR  A
0827   440E C9              RET
0828   440F             
0829   440F             ; Text in HL, FF marks end
0830   440F             PRINTTEXT:
0831   440F 7E          HLP1:	LD A,(HL)
0832   4410 FE FF       	CP $FF
0833   4412 C8          	RET Z
0834   4413 D7              RST 10H
0835   4414 23          	INC HL
0836   4415 18 F8       	JR HLP1
0837   4417             
0838   4417             
0839   4417             ; *
0840   4417             ; * PRINT HL DECIMAL
0841   4417             ; *
0842   4417             PRINTBASE10:
0843   4417 E5          	PUSH HL
0844   4418 C5          	PUSH BC
0845   4419 D5          	PUSH DE
0846   441A AF              XOR A
0847   441B F5          	PUSH AF
0848   441C             _PRTLP:
0849   441C CD 31 44    	CALL _DIV10
0850   441F C6 1C       	ADD A,1CH
0851   4421 F5          	PUSH AF
0852   4422 7C          	LD A,H
0853   4423 B5          	OR L
0854   4424 20 F6       	JR NZ,_PRTLP
0855   4426             _PRTL1:
0856   4426 F1          	POP AF
0857   4427 B7          	OR A
0858   4428 20 04       	JR NZ,_PRT2
0859   442A D1          	POP DE
0860   442B C1          	POP BC
0861   442C E1          	POP HL
0862   442D C9          	RET
0863   442E             _PRT2
0864   442E D7          	RST 10H
0865   442F 18 F5       	JR _PRTL1
0866   4431             ; * HL=HL/10 A=REMAINDE
0867   4431             _DIV10:
0868   4431 06 10       	LD B,10h
0869   4433 AF          	XOR A
0870   4434             _DIVLP:
0871   4434 CB 25       	SLA L
0872   4436 CB 14       	RL H
0873   4438 17          	RLA
0874   4439 FE 0A       	CP 0Ah
0875   443B 38 04       	JR C,_SK
0876   443D CB C5       	SET 0,L
0877   443F D6 0A       	SUB 0Ah
0878   4441             _SK:
0879   4441 10 F1       	DJNZ _DIVLP
0880   4443 C9          	RET
0881   4444             
0882   4444             
0883   4444             GO_QSAVE_MODE:
0884   4444 CD E7 02    	CALL FAST	; go to fast mode
0885   4447 DB FE           IN      A,($FE)         ; signal to 0 pause    
0886   4449 06 C8           LD B,200  ; 200=200ms Pause
0887   444B C5          W1: push BC
0888   444C 06 00           ld b,0
0889   444E             W2:
0890   444E 10 FE           djnz W2     ; 1 millisec (256*4)
0891   4450 C1              pop BC
0892   4451 10 F8           djnz W1
0893   4453 1E 4B           LD E, 75    ; ID for ZX_SAVE_TAG_QSAVE_START
0894   4455 CD 1F 03        CALL $031F  ; SAVE byte in E
0895   4458 D3 FF           OUT     ($FF),A         ; ; signal to 1 / syncoff, send hsyncs
0896   445A 06 00           ld b,0
0897   445C             W4:
0898   445C 10 FE           djnz W4     ; 1 millisec (256*4) to go to QSAVE mode
0899   445E C9              RET
0900   445F             
0901   445F             TRY_HANDSHAKE:  ; See if WESPI responds, return 1 if so, 0 for timeout
0902   445F             AA30:
0903   445F CD 44 44        CALL GO_QSAVE_MODE
0904   4462 21 04 40        ld   hl, 16388 ; RAMTOP
0905   4465 06 02           ld   B,2
0906   4467 0E 5A           ld   C,90 ; packet ID ZX_QSAVE_TAG_HANDSHAKE
0907   4469             AA31:
0908   4469 CD DC 44        CALL SEND_PACKET
0909   446C 06 B5           ld   b,181  ; timeout, 500ms (inner loop 3.15ms)
0910   446E             HS_LOOP1:
0911   446E C5              PUSH BC
0912   446F 06 00           LD   B,0
0913   4471             HS_LOOP2:                  ; 35 cycles=10.7us, inner Loop 2.75 millisec
0914   4471 DB FE           in a,($FE)  ; 11
0915   4473 17              rla         ; 4
0916   4474 38 0E           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0917   4476 10 F9           DJNZ HS_LOOP2 ;13
0918   4478                 ; re-check here to not have a blind spot for outer loop
0919   4478 DB FE           in a,($FE)  ; 11
0920   447A 17              rla         ; 4
0921   447B 38 07           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0922   447D D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff in between to not let levels drift (not good for follow-up cmds?)
0923   447F C1              POP  BC
0924   4480 10 EC           DJNZ HS_LOOP1
0925   4482                 ; no signal found
0926   4482 AF              XOR  A
0927   4483 C9              RET
0928   4484             
0929   4484             HS_FOUND
0930   4484 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0931   4486                 ; let the output recover with active signal after being low from input. takes about 1ms as seen in oscilloscope
0932   4486 06 00           LD   B,0
0933   4488             HS_FINALDELAY: ; 3ms here before next cmd
0934   4488 7E              LD   A,(HL)
0935   4489 7E              LD   A,(HL)
0936   448A 7E              LD   A,(HL)    
0937   448B 7E              LD   A,(HL)    
0938   448C 10 FA           DJNZ HS_FINALDELAY
0939   448E C1              POP  BC
0940   448F 3E 01           LD   A,1
0941   4491 A7              AND  A
0942   4492 C9              RET
0943   4493             
0944   4493             QS_FINAL_SZ:
0945   4493 00              db 0 ; size of return packet to request, use smallest possible
0946   4494             
0947   4494             QS_FINAL_ACK:  ; Get info is operation was sussessful (Z) or failed (NZ), USES BC DE HL, A
0948   4494 21 93 44        ld   hl, QS_FINAL_SZ ; Requested length
0949   4497 06 01           ld   B,1
0950   4499 0E 63           LD   C,99 ; packet ID ZX_QSAVE_TAG_END_RQ
0951   449B             AA32:
0952   449B CD DC 44        CALL SEND_PACKET
0953   449E             
0954   449E                 ; await reply, first byte is tag, then result
0955   449E             AA33:
0956   449E CD AE 44        CALL QLD_GETBYTE
0957   44A1 FE 2A           CP   42 ; tag
0958   44A3 C0              RET  NZ
0959   44A4 06 08           ld B,8  ; 
0960   44A6             QSFDLY:
0961   44A6 10 0F           djnz lgapdly     ; 13*n-5 = 47 for 4
0962   44A8             AA34:
0963   44A8 CD AE 44        CALL QLD_GETBYTE
0964   44AB FE 01           CP   1 ; result
0965   44AD C9              RET    ; Z on match
0966   44AE             
0967   44AE             
0968   44AE             
0969   44AE             ; gab between byte calls should be 77+12+7 - 17-10 = 69 clocks
0970   44AE             
0971   44AE             QLD_GETBYTE:    ; uses BC D, result in A
0972   44AE 0E FE           ld c,$fe   ; 7
0973   44B0 06 08           ld b,8  ; 7    for gap between start and bits
0974   44B2             
0975   44B2             lwt_stdly:                  ; 25 cycles=7.7us
0976   44B2 DB FE           in a,($FE)  ; 11
0977   44B4 17              rla         ; 4
0978   44B5 30 FB           jr nc,lwt_stdly ; 12 / 7  (D7=0 is low level, wait for high)
0979   44B7                 ; trigger is seen 4us too late in average, so wait 48-4 - 4 us now: 130 cy in-in
0980   44B7             lgapdly:
0981   44B7 10 FE           djnz lgapdly     ; 13*n-5 = 99 for 8
0982   44B9 06 08           ld b,8  ; 7
0983   44BB             lbloop:                 ;  need 104 for 32us
0984   44BB ED 50           in d,(c)    ; 12
0985   44BD CB 12           rl d        ; 8
0986   44BF 17              rla         ; 4 (rl a is 8)
0987   44C0 16 04           ld d,4      ; 7
0988   44C2             lbdly:
0989   44C2 15              dec d          ; 4          b*16-5 = 59
0990   44C3 20 FD           jr nz,lbdly     ; 12 / 7
0991   44C5 10 F4           djnz lbloop     ; 13 / 8
0992   44C7 C9              RET     
0993   44C8                 
0994   44C8                 ;ORIGINAL:
0995   44C8                 ;ld (hl),a   ; 7
0996   44C8             	;CALL UPDATE  ; will use DE, inc HL    77 clks
0997   44C8                 ;jr lwt_start     ; 12
0998   44C8             
0999   44C8             
1000   44C8             
1001   44C8             
1002   44C8             ;*
1003   44C8             ;* Evaluate string  start of the string is in HL and the length in BC
1004   44C8             ;*
1005   44C8 E7          NAME:	RST 20h
1006   44C9 CD 55 0F    	CALL 0F55h ; evaluate
1007   44CC 3A 01 40    	LD A,(4001h)
1008   44CF 87          	ADD A,A
1009   44D0 FA 9A 0D    	JP M,0D9Ah  ; error
1010   44D3 E1          	POP HL
1011   44D4 D0          	RET NC
1012   44D5 E5          	PUSH HL
1013   44D6 CD F8 13    	CALL 13F8h ; get indexvar fom calc stack STK-FETCH
1014   44D9                 ; For strings, the start of the string is in DE and the length in BC
1015   44D9 62          	LD H,D
1016   44DA 6B          	LD L,E
1017   44DB C9          	RET
1018   44DC             
1019   44DC             
1020   44DC             SEND_PACKET: ; HL points to data, C holds type, B lenght (0=256bytes), HL will point behind sent data afterwards
1021   44DC F5              PUSH AF
1022   44DD C5              PUSH BC ; BC needed twice, for header, and recovered at end
1023   44DE C5              PUSH BC
1024   44DF             
1025   44DF 06 E1           LD B,225    ;   TODO 125 should be enough
1026   44E1             SPWT:
1027   44E1 10 FE           djnz SPWT     ; 500 microsec  (125*4)  ; let the video lines sync again, require 5 lines (320), some margin added
1028   44E3             
1029   44E3                 ; we want all our pulses in sync with the HSYNC pulses to not interfere   
1030   44E3 AF              XOR A       ; make sure A' not at sync or display position to
1031   44E4 08              EX AF,AF'   ; just cause short INT on MNI here:
1032   44E5                             
1033   44E5 D3 FE           OUT ($FE),A  ; ENABLE NMI
1034   44E7 76              HALT
1035   44E8 D3 FD           OUT ($FD),A  ; Disable NMI   from here, start first bit in 54us =174cy
1036   44EA DB FE           IN      A,($FE)         ; signal to 0 /on - syncout
1037   44EC 7E              LD   A,(HL)     ; 7 dummy 
1038   44ED 00              NOP             ; 4
1039   44EE 06 07           LD   B,7
1040   44F0 00              NOP             ; timing adjust to have bits symmetrical in (black-shouldered) line
1041   44F1 D3 FF           OUT     ($FF),A ;11        ; signal to 1 / syncoff
1042   44F3             waitnline:
1043   44F3 10 FE           DJNZ waitnline          ; delay for next line 13 per loop ..
1044   44F5 C1              POP  BC            ;10
1045   44F6             
1046   44F6             
1047   44F6                 ; Send packettype in C
1048   44F6             AA35:
1049   44F6 CD 3C 45        CALL SENDNIBBLE ;151, so we need 56 cycles between nibbles to get to 207 for one hsync line
1050   44F9             
1051   44F9 23              INC  HL         ; 6  ; DUMMY matching later dec
1052   44FA 7E              LD   A,(HL)     ; 7 
1053   44FB D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1054   44FD 7E              LD   A,(HL)     ; 7 
1055   44FE 7E              LD   A,(HL)     ; 7 
1056   44FF 7E              LD   A,(HL)     ; 7 
1057   4500 7E              LD   A,(HL)     ; 7 
1058   4501 00              NOP
1059   4502             AA36:
1060   4502 CD 3C 45        CALL SENDNIBBLE ;151
1061   4505             
1062   4505 2B              DEC  HL 
1063   4506 7E              LD   A,(HL)     ; 7 
1064   4507 D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
1065   4509 7E              LD   A,(HL)     ; 7 
1066   450A 7E              LD   A,(HL)     ; 7 
1067   450B 7E              LD   A,(HL)     ; 7 
1068   450C 7E              LD   A,(HL)     ; 7 
1069   450D 48              LD C,B             ;4
1070   450E             
1071   450E                 ; Send length in B
1072   450E             AA37:
1073   450E CD 3C 45        CALL SENDNIBBLE ;151
1074   4511             
1075   4511 23              INC  HL         ; 6  ; DUMMY matching later dec
1076   4512 7E              LD   A,(HL)     ; 7 
1077   4513 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1078   4515 7E              LD   A,(HL)     ; 7 
1079   4516 7E              LD   A,(HL)     ; 7 
1080   4517 7E              LD   A,(HL)     ; 7 
1081   4518 7E              LD   A,(HL)     ; 7 
1082   4519 00              NOP             ; 4
1083   451A             AA38:
1084   451A CD 3C 45        call SENDNIBBLE ;151
1085   451D             
1086   451D 2B              DEC  HL 
1087   451E 7E              LD   A,(HL)     ; 7 
1088   451F             byteloop:
1089   451F D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
1090   4521 7E              LD   A,(HL)     ; 7 
1091   4522 7E              LD   A,(HL)     ; 7 
1092   4523 7E              LD   A,(HL)     ; 7 
1093   4524 4E              LD   C,(HL)     ; 7 
1094   4525 00              NOP
1095   4526             AA39:
1096   4526 CD 3C 45        call SENDNIBBLE ;151
1097   4529 23              INC  HL         ; 6
1098   452A 7E              LD   A,(HL)     ; 7 
1099   452B D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1100   452D 7E              LD   A,(HL)     ; 7 
1101   452E 7E              LD   A,(HL)     ; 7 
1102   452F 7E              LD   A,(HL)     ; 7 
1103   4530 7E              LD   A,(HL)     ; 7 
1104   4531 00              NOP
1105   4532                                 ; 56
1106   4532             AA40:    
1107   4532 CD 3C 45        CALL SENDNIBBLE ;151
1108   4535 10 E8           DJNZ byteloop   ; 13
1109   4537 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1110   4539             
1111   4539 C1              POP  BC
1112   453A F1              POP  AF
1113   453B C9              ret
1114   453C             
1115   453C             
1116   453C             SENDNIBBLE: ;31 per bit, 134 incl RET 151 incl call, nibble in C lower half
1117   453C                 ; Four bits to send
1118   453C                 ;# bit 1 start
1119   453C CB 01           RLC C       ; 8
1120   453E 38 19           JR C, csendH1 ; 12/7
1121   4540 D8              ret c        ; 11/5 dummy for symmetric timing
1122   4541                 ;# bit 1 send 0
1123   4541 DB FE           IN      A,($FE)         ; signal to 0 /on
1124   4543             
1125   4543                 ;# bit 2 start
1126   4543 CB 01           RLC C       ; 8
1127   4545 38 2A           JR C, csendH2 ; 12/7
1128   4547 D8              ret c        ; 11/5 dummy for symmetric timing
1129   4548                 ;# bit 2 send 0
1130   4548 DB FE           IN      A,($FE)         ; signal to 0 /on
1131   454A             
1132   454A                 ;# bit 3 start
1133   454A CB 01           RLC C       ; 8
1134   454C 38 34           JR C, csendH3 ; 12/7
1135   454E D8              ret c        ; 11/5 dummy for symmetric timing
1136   454F                 ;# bit 3 send 0
1137   454F DB FE           IN      A,($FE)         ; signal to 0 /on
1138   4551             
1139   4551                 ;# bit 4 start
1140   4551 CB 01           RLC C       ; 8
1141   4553 38 37           JR C, csendH4 ; 12/7
1142   4555 D8              ret c        ; 11/5 dummy for symmetric timing
1143   4556                 ;# bit 4 send 0
1144   4556 DB FE           IN      A,($FE)         ; signal to 0 /on
1145   4558             
1146   4558 C9              ret
1147   4559             
1148   4559             
1149   4559             csendH1:    ;# bit 1 send 1
1150   4559 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1151   455B             
1152   455B                 ;# bit 2 start
1153   455B CB 01           RLC C       ; 8
1154   455D 38 12           JR C, csendH2 ; 12/7
1155   455F D8              ret c        ; 11/5 dummy for symmetric timing
1156   4560                 ;# bit 2 send 0
1157   4560 DB FE           IN      A,($FE)         ; signal to 0 /on
1158   4562             
1159   4562                 ;# bit 3 start
1160   4562 CB 01           RLC C       ; 8
1161   4564 38 1C           JR C, csendH3 ; 12/7
1162   4566 D8              ret c        ; 11/5 dummy for symmetric timing
1163   4567                 ;# bit 3 send 0
1164   4567 DB FE           IN      A,($FE)         ; signal to 0 /on
1165   4569             
1166   4569                 ;# bit 4 start
1167   4569 CB 01           RLC C       ; 8
1168   456B 38 1F           JR C, csendH4 ; 12/7
1169   456D D8              ret c        ; 11/5 dummy for symmetric timing
1170   456E                 ;# bit 4 send 0
1171   456E DB FE           IN      A,($FE)         ; signal to 0 /on
1172   4570 C9              ret
1173   4571             
1174   4571             csendH2:    ;# bit 2 send 1
1175   4571 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1176   4573             
1177   4573                 ;# bit 3 start
1178   4573 CB 01           RLC C       ; 8
1179   4575 38 0B           JR C, csendH3 ; 12/7
1180   4577 D8              ret c        ; 11/5 dummy for symmetric timing
1181   4578                 ;# bit 3 send 0
1182   4578 DB FE           IN      A,($FE)         ; signal to 0 /on
1183   457A             
1184   457A                 ;# bit 4 start
1185   457A CB 01           RLC C       ; 8
1186   457C 38 0E           JR C, csendH4 ; 12/7
1187   457E D8              ret c        ; 11/5 dummy for symmetric timing
1188   457F                 ;# bit 4 send 0
1189   457F DB FE           IN      A,($FE)         ; signal to 0 /on
1190   4581 C9              ret
1191   4582             
1192   4582             csendH3:    ;# bit 3 send 1
1193   4582 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1194   4584             
1195   4584                 ;# bit 4 start
1196   4584 CB 01           RLC C       ; 8
1197   4586 38 04           JR C, csendH4 ; 12/7
1198   4588 D8              ret c        ; 11/5 dummy for symmetric timing
1199   4589                 ;# bit 4 send 0
1200   4589 DB FE           IN      A,($FE)         ; signal to 0 /on
1201   458B C9              ret
1202   458C             
1203   458C             csendH4:    ;# bit 4 send 1
1204   458C D3 FF           OUT     ($FF),A         ; signal to 1 /off
1205   458E C9              ret
1206   458F             
1207   458F             DRIVER_END:
1208   458F             
1209   458F 76             db $76   ;N/L 
1210   4590             
1211   4590             line10:
1212   4590 00 0A          db 0,10  ;line number 
1213   4592 13 00          dw dfile-$-2  ;line length 
1214   4594 F5             db $f5   ;PRINT 
1215   4595 D4             db $d4   ;USR 
1216   4596 1D             db $1d   ;1 
1217   4597 22             db $22   ;6 
1218   4598 21             db $21   ;5 
1219   4599 1D             db $1d   ;1 
1220   459A 20             db $20   ;4 
1221   459B 7E             db $7e   ;FP mark 
1222   459C 8F             db $8f   ;5 bytes FP number 
1223   459D 01             db $01   ; 
1224   459E 04             db $04   ; 
1225   459F 00             db $00   ; 
1226   45A0 00             db $00   ; 
1227   45A1 1A             db $1a   ; ,
1228   45A2 0B             db $0b   ; "
1229   45A3              ;  db c_H   ; Help
1230   45A3 29             db c_D   ; Dir
1231   45A4             
1232   45A4              ;  db c_I   ; I 10000 install
1233   45A4                ;db c_I   ; TTTT2 = QLOAD test
1234   45A4                ;db c_T   ; SNNN = dummy save for testing
1235   45A4                ;db c_S   ; STST,1024,100 binsave
1236   45A4                ;db c_T   ; LTST,1024   binload
1237   45A4              ;  db 0   ; 
1238   45A4              ;  db c_0+1   ; 
1239   45A4              ;  db c_0+0   ; 
1240   45A4              ;  db c_0+0   ; 
1241   45A4              ;  db c_0+0   ; 
1242   45A4              ;  db c_0+0   ; 
1243   45A4             ;   db 26
1244   45A4             ;   db c_0+1   ; 
1245   45A4             ;   db c_0+0   ; 
1246   45A4             ;   db c_0+0   ; 
1247   45A4 0B             db $0b   ; "
1248   45A5 76             db $76   ;N/L 
1249   45A6 76             db $76   ;N/L 
1250   45A7             
1251   45A7             
1252   45A7                
1253   45A7             ;- Display file -------------------------------------------- 
1254   45A7              
1255   45A7             dfile: 
1256   45A7 76             db $76 
1257   45A8 3F 3D          db c_Z,c_X,
1258   45AA 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1258   45AE 76 76 76 76 
1259   45B2 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1259   45B6 76 76 76 76 
1260   45BA 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1260   45BE 76 76 76 76 
1261   45C2              
1262   45C2             ;- BASIC-Variables ---------------------------------------- 
1263   45C2              
1264   45C2             var: 
1265   45C2 80             db $80 
1266   45C3              
1267   45C3             ;- End of program area ---------------------------- 
1268   45C3             
1269   45C3             last: 
1270   45C3              
1271   45C3                end 
tasm: Number of errors = 0
