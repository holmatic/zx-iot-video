0001   0000             ; SYSINFO81 
0002   0000             ; 	GPL
0003   0000             ; 	Oliver Lange
0004   0000             ; 	Version 1.0.1
0005   0000             
0006   0000             ; Compile with "tasm -80 -b wspdrv.asm wspdrv.p" 
0007   0000             
0008   0000             
0009   0000             ; driver for wespi
0010   0000             ;
0011   0000             
0012   0000             
0013   0000              
0014   0000             #define db .byte ;  cross-assembler definitions 
0015   0000             #define dw .word 
0016   0000             #define ds .block 
0017   0000             #define org .org 
0018   0000             #define end .end 
0019   0000             
0020   0000             
0021   0000             
0022   0000             #define ADDR_DISABLE 0
0023   0000             #define UPDATE	01FCh	; LOAD/SAVE adress update subroutine in ROM
0024   0000             
0025   0000             ;;#define VERBOSE 1
0026   0000              
0027   4009             org     $4009 ; BASIC PROGRAMM
0028   4009             ;= System variables ============================================ 
0029   4009              
0030   4009 00             db 0     	;VERSN 
0031   400A 00 00          dw 0     	;E_PPC 
0032   400C BB 45          dw dfile      ;D_FILE 
0033   400E BC 45          dw dfile+1    ;DF_CC 
0034   4010 D6 45          dw var   	;VARS 
0035   4012 00 00          dw 0     	;DEST 
0036   4014 D7 45          dw var+1      ;E_LINE 
0037   4016 D6 45          dw last-1     ;c_ADD 
0038   4018 00 00          dw 0     	;X_PTR 
0039   401A D7 45          dw last  	;STKBOT 
0040   401C D7 45          dw last  	;STKEND 
0041   401E 00             db 0     	;BERG 
0042   401F 5D 40          dw membot     ;MEM 
0043   4021 00             db 0     ;not used 
0044   4022 02             db 2     ;DF_SZ 
0045   4023 01 00          dw 1     ;S_TOP 
0046   4025 FF FF FF       db $FF,$FF,$FF     ;LAST_K 
0047   4028 37             db 55    ;MARGIN 
0048   4029 A4 45          dw line10     ;NXTLIN   line10   dfile
0049   402B 00 00          dw 0     ;OLDPPC 
0050   402D 00             db 0     ;FLAGX 
0051   402E 00 00          dw 0     ;STRLEN 
0052   4030 8D 0C          dw $0C8D      ;T_ADDR 
0053   4032 00 00          dw 0     ;SEED 
0054   4034 FF FF          dw $FFFF      ;FRAMES 
0055   4036 00 00          db 0,0   ;COORDS 
0056   4038 BC             db $BC   ;PR_CC 
0057   4039 21 18          db 33,24      ;S_POSN 
0058   403B 40             db 01000000B  ;CDFLAG 
0059   403C                ds 33    ;Print buffer --- now used for loader code, all loaded programs need to have the same !
0060   405D             
0061   405D             membot: 
0062   405D                ds 30    ;Calculator�s memory area 
0063   407B                ds 2     ;not used 
0064   407D              
0065   407D             ;= First BASIC line, asm code ================================== 
0066   407D              
0067   407D             line0: 
0068   407D 00 00          db 0,0   ;line number 
0069   407F 23 05          dw line10-$-2 ;line length 
0070   4081 EA             db $ea   ; REM 
0071   4082             
0072   4082             
0073   4082             #define ELINE	4014h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0074   4082             #define ELINEHI	4015h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0075   4082             
0076   4082             #define SHOW	0207h  ; ROM-Routinen
0077   4082             #define FAST	02E7h
0078   4082             #define RCLS	0A2Ah
0079   4082             #define GETKEY	02BBh
0080   4082             
0081   4082             
0082   4082             #DEFINE RST_PRTCHAR RST 10H
0083   4082             #DEFINE c_SPACE 0
0084   4082             #DEFINE c_NEWLINE 76H
0085   4082             #DEFINE c_0 1CH
0086   4082             
0087   4082             #DEFINE c_A 26H
0088   4082             #DEFINE c_B c_A+1
0089   4082             #DEFINE c_C c_A+2
0090   4082             #DEFINE c_D c_A+3
0091   4082             #DEFINE c_E c_A+4
0092   4082             #DEFINE c_F c_A+5
0093   4082             #DEFINE c_G c_A+6
0094   4082             #DEFINE c_H c_A+7
0095   4082             #DEFINE c_I c_A+8
0096   4082             #DEFINE c_J c_A+9
0097   4082             #DEFINE c_K c_J+1
0098   4082             #DEFINE c_L c_J+2
0099   4082             #DEFINE c_M c_J+3
0100   4082             #DEFINE c_N c_J+4
0101   4082             #DEFINE c_O c_J+5
0102   4082             #DEFINE c_P c_J+6
0103   4082             #DEFINE c_Q c_J+7
0104   4082             #DEFINE c_R c_J+8
0105   4082             #DEFINE c_S c_J+9
0106   4082             #DEFINE c_T c_S+1
0107   4082             #DEFINE c_U c_S+2
0108   4082             #DEFINE c_V c_S+3
0109   4082             #DEFINE c_W c_S+4
0110   4082             #DEFINE c_X c_S+5
0111   4082             #DEFINE c_Y c_S+6
0112   4082             #DEFINE c_Z c_S+7
0113   4082             
0114   4082             #define UFM_ERRNO 16434 ; Definiert in UFM, Fehlercode 1 Byte (eigentlich SEED)
0115   4082             #define UFM_CMDBUF 16444 ; Definiert in UFM, 32 Byte, alternative Kommando�bergabe (eigentlich PRBUF)
0116   4082             #define UFM_COORDS 16438 ; L�ngen�bergabe 2 Byte (eigentlich COORDS)
0117   4082             
0118   4082             
0119   4082             ;
0120   4082             ;   === Main entry point ====
0121   4082             ;
0122   4082             DRIVER_START:
0123   4082             BASIC_START:
0124   4082             AA45:
0125   4082 CD DC 44    	CALL NAME	; get command line arg
0126   4085 18 1B       	JR BASIC_CONT
0127   4087 00          	NOP
0128   4088 00          	NOP
0129   4089 00          	NOP
0130   408A             
0131   408A             CALL_START:	; (IN UFM als START_ADDR+6 festgelegt)
0132   408A 21 3C 40    	LD HL,UFM_CMDBUF
0133   408D E5              PUSH HL
0134   408E                 ;  get length in BC by parsing for '"' or so..
0135   408E 01 00 00        LD   BC,0
0136   4091             ENDPRSLP:
0137   4091 7E              LD   A,(HL)
0138   4092 FE 0B           CP   11     ; is " ?
0139   4094 28 04           JR   Z, EXITPRSLP
0140   4096 03              INC  BC
0141   4097 23              INC  HL
0142   4098 18 F7           JR   ENDPRSLP
0143   409A             EXITPRSLP:
0144   409A E1              POP  HL ; original pointer
0145   409B             AA44:
0146   409B CD BA 40    	CALL GENER_START
0147   409E 32 32 40    	LD (UFM_ERRNO),A
0148   40A1 C9          	RET
0149   40A2             
0150   40A2             BASIC_CONT:
0151   40A2             AA01:
0152   40A2 CD BA 40    	CALL GENER_START ; A is 0 for ok, !=0 for error
0153   40A5 A7          	AND A
0154   40A6 28 0F       	JR Z,BAS_OK
0155   40A8 3E 2A       	LD A,c_E		; Ausgabe ERR
0156   40AA D7          	RST 10h 
0157   40AB 3E 37       	LD A,c_R
0158   40AD D7          	RST 10h
0159   40AE 3E 37           LD A,c_R
0160   40B0 D7          	RST 10h
0161   40B1 3E 76           LD A,c_NEWLINE
0162   40B3 D7          	RST 10h
0163   40B4                 ; exit
0164   40B4 AF              XOR A
0165   40B5 CF          	RST 08h
0166   40B6 09              db  09h             ; Error Report: Invalid argument
0167   40B7             	;db 0FFh
0168   40B7             
0169   40B7             BAS_OK:
0170   40B7             	; RET  ; TODO check if RET or better RST8 with -1
0171   40B7 AF              XOR A		; sonst zurueck nach BASIC
0172   40B8 CF          	RST 08h
0173   40B9 FF          	db 0FFh
0174   40BA             	
0175   40BA             
0176   40BA             GENER_START: ; Interpreting the string independent of its origin, on ret A=0 for okay, BC retval to basic
0177   40BA 7E          	LD A,(HL)   ; HL=start, BC=length
0178   40BB 23              INC  HL
0179   40BC 0B              DEC  BC
0180   40BD             AA00:
0181   40BD 11 E5 40        LD   DE,GENER_END
0182   40C0 D5              PUSH DE     ; ret adddess
0183   40C1             ;	CP c_I		; Info
0184   40C1             ;	JP Z,INFO1
0185   40C1 FE 38       	CP c_S		; Save
0186   40C3             AA41:
0187   40C3 CA D4 42    	JP Z,SAVE1
0188   40C6 FE 31       	CP c_L		; Load
0189   40C8             AA42:
0190   40C8 CA E0 41    	JP Z,LOAD1
0191   40CB             ;	CP 29h		; ist es ein D;
0192   40CB             ;	JP Z,DIR1
0193   40CB             ;	CP 3Bh		; ist es ein V (UFM)
0194   40CB             ;	JP Z,DIRV1
0195   40CB             ;	CP 30h		; ist es ein K (UFM)
0196   40CB             ;	JP Z,DIRK1
0197   40CB             ;	CP 37h		; ist es ein R
0198   40CB             ;	JP Z,RENAM1
0199   40CB             ;	CP 2Ah		; ist es ein E
0200   40CB             ;	JP Z,ERAS1
0201   40CB FE 2E       	CP c_I		;  I
0202   40CD             AA02:
0203   40CD CA ED 40    	JP Z,INST_RELOC
0204   40D0 FE 39       	CP c_T		; Test, return 0...1023 dependng on number of correct bytes
0205   40D2             AA43:
0206   40D2 CA A8 42    	JP Z,TESTPATTERN
0207   40D5 FE 29       	CP c_D		; Directory
0208   40D7             AA52:
0209   40D7 CA E0 41    	JP Z,LOAD1
0210   40DA FE 2D       	CP c_H		; Help
0211   40DC             AA03:
0212   40DC CA 0A 44    	JP Z,HLP
0213   40DF FE 0F       	CP 0Fh		; ist es ein ?
0214   40E1             AA04:
0215   40E1 CA 0A 44    	JP Z,HLP
0216   40E4 C9              ret 
0217   40E5             
0218   40E5             GENER_END:
0219   40E5 F5              PUSH AF ; holds our error status
0220   40E6 C5              PUSH BC ; ret value...
0221   40E7 CD 07 02    	CALL SHOW
0222   40EA C1              POP  BC
0223   40EB F1              POP  AF
0224   40EC C9          	RET
0225   40ED             	
0226   40ED             INST_RELOC:
0227   40ED                 ; address with new memory location follows. Cpoies the driver and corrects the absolute adresses accordingly
0228   40ED             AA09:
0229   40ED CD 69 42        CALL PARS_DEC_NUM   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0230   40F0 3E 01           LD   A,1
0231   40F2 C0              RET  NZ
0232   40F3 D5              PUSH DE
0233   40F4 CD E7 02    	CALL FAST	; go to fast mode so we can use index regs
0234   40F7 D1              POP  DE
0235   40F8 DD E5           PUSH IX     ; save IX till end
0236   40FA D5              PUSH DE
0237   40FB DD E1           POP  IX     ; new start addr in IX, will need it quite often
0238   40FD                 ; copy RAW driver
0239   40FD             AA06:
0240   40FD 21 82 40        LD HL,DRIVER_START
0241   4100 01 21 05        LD BC,DRIVER_END-DRIVER_START
0242   4103 ED B0           LDIR
0243   4105                 ; correct abs addr occurrences, all in this table:
0244   4105             AA07:
0245   4105 21 4C 41        LD HL, RELOC_TABLE
0246   4108             RLCLOOP:
0247   4108 5E              LD   E,(HL)
0248   4109 23              INC  HL
0249   410A 56              LD   D,(HL)
0250   410B 23              INC  HL
0251   410C 7A              LD   A,D
0252   410D B3              OR  E
0253   410E 28 1C           JR   Z, ENDRLCCP    ; null end marker
0254   4110 E5              PUSH HL ; next RELOC_TABLE pos
0255   4111                 ; DE is position of the addr tag relative to start
0256   4111 DD E5           PUSH IX
0257   4113 E1              POP  HL
0258   4114 19              ADD  HL,DE
0259   4115                 ; HL is the absolute label pos to modify
0260   4115 E5              PUSH HL ; need it later to write
0261   4116 5E              LD   E,(HL) 
0262   4117 23              INC  HL
0263   4118 56              LD   D,(HL)
0264   4119             AA05:
0265   4119 21 82 40        LD   HL, DRIVER_START
0266   411C EB              EX   DE,HL
0267   411D A7          	AND A		; clear carry
0268   411E ED 52       	SBC HL,DE	; actual address minus old offset
0269   4120             
0270   4120                 ; HL is relative addr
0271   4120 DD E5           PUSH IX
0272   4122 D1              POP  DE
0273   4123 19              ADD  HL,DE  ; add new offset
0274   4124 EB              EX   DE,HL
0275   4125                 ; DE is new abs addr
0276   4125 E1              POP  HL
0277   4126 73              LD   (HL),E
0278   4127 23              INC  HL
0279   4128 72              LD   (HL),D
0280   4129 E1              POP HL ; restore RELOC_TABLE pos
0281   412A 18 DC           JR RLCLOOP
0282   412C             ENDRLCCP:
0283   412C DD E1           POP  IX
0284   412E AF              XOR  A
0285   412F 01 21 05        LD   BC,DRIVER_END-DRIVER_START
0286   4132 C9              RET
0287   4133              
0288   4133             
0289   4133             PRINTHEX:
0290   4133 F5          	PUSH AF
0291   4134 E5          	PUSH HL
0292   4135 C5          	PUSH BC
0293   4136 4F          	LD C,A		; SAVE
0294   4137 CB 3F       	SRL A
0295   4139 CB 3F       	SRL A
0296   413B CB 3F       	SRL A
0297   413D CB 3F       	SRL A
0298   413F C6 1C       	ADD A,1CH	; Offset to '0'
0299   4141 D7          	RST 10H
0300   4142 79          	LD A,C
0301   4143 E6 0F       	AND	0FH		; MASK
0302   4145 C6 1C       	ADD A,1CH	; Offset to '0'
0303   4147 D7          	RST 10H
0304   4148 C1          	POP BC
0305   4149 E1          	POP HL
0306   414A F1          	POP AF
0307   414B C9          	RET
0308   414C             
0309   414C             
0310   414C             RELOC_TABLE:
0311   414C              ;   dw 0
0312   414C 3C 00           dw AA00+1-DRIVER_START
0313   414E 21 00           dw AA01+1-DRIVER_START
0314   4150 4C 00           dw AA02+1-DRIVER_START
0315   4152 5B 00           dw AA03+1-DRIVER_START
0316   4154 60 00           dw AA04+1-DRIVER_START
0317   4156 98 00           dw AA05+1-DRIVER_START
0318   4158 7C 00           dw AA06+1-DRIVER_START
0319   415A 84 00           dw AA07+1-DRIVER_START
0320   415C 89 03           dw AA08+1-DRIVER_START
0321   415E 6C 00           dw AA09+1-DRIVER_START
0322   4160             
0323   4160 63 01           dw AA10+1-DRIVER_START
0324   4162 70 01           dw AA11+1-DRIVER_START
0325   4164 73 01           dw AA12+1-DRIVER_START
0326   4166 7F 01           dw AA13+1-DRIVER_START
0327   4168 88 01           dw AA14+1-DRIVER_START
0328   416A 9B 01           dw AA15+1-DRIVER_START
0329   416C A5 01           dw AA16+1-DRIVER_START
0330   416E C2 01           dw AA17+1-DRIVER_START
0331   4170 29 02           dw AA18+1-DRIVER_START
0332   4172 34 02           dw AA19+1-DRIVER_START
0333   4174             
0334   4174 3D 02           dw AA20+1-DRIVER_START
0335   4176 55 02           dw AA21+1-DRIVER_START
0336   4178 5F 02           dw AA22+1-DRIVER_START
0337   417A 74 02           dw AA23+1-DRIVER_START
0338   417C 7E 02           dw AA24+1-DRIVER_START
0339   417E 8C 02           dw AA25+1-DRIVER_START
0340   4180 9A 02           dw AA26+1-DRIVER_START
0341   4182 9D 02           dw AA27+1-DRIVER_START
0342   4184 A9 02           dw AA28+1-DRIVER_START
0343   4186 B1 02           dw AA29+1-DRIVER_START
0344   4188             
0345   4188 F2 03           dw AA30+1-DRIVER_START
0346   418A FC 03           dw AA31+1-DRIVER_START
0347   418C 2E 04           dw AA32+1-DRIVER_START
0348   418E 31 04           dw AA33+1-DRIVER_START
0349   4190 3B 04           dw AA34+1-DRIVER_START
0350   4192 89 04           dw AA35+1-DRIVER_START
0351   4194 95 04           dw AA36+1-DRIVER_START
0352   4196 A1 04           dw AA37+1-DRIVER_START
0353   4198 AD 04           dw AA38+1-DRIVER_START
0354   419A B9 04           dw AA39+1-DRIVER_START
0355   419C             
0356   419C C5 04           dw AA40+1-DRIVER_START
0357   419E 42 00           dw AA41+1-DRIVER_START
0358   41A0 47 00           dw AA42+1-DRIVER_START
0359   41A2 51 00           dw AA43+1-DRIVER_START
0360   41A4 1A 00           dw AA44+1-DRIVER_START
0361   41A6 01 00           dw AA45+1-DRIVER_START
0362   41A8 8C 03           dw AA46+1-DRIVER_START
0363   41AA 8F 03           dw AA47+1-DRIVER_START
0364   41AC 92 03           dw AA48+1-DRIVER_START
0365   41AE 95 03           dw AA49+1-DRIVER_START
0366   41B0             
0367   41B0 98 03           dw AA50+1-DRIVER_START
0368   41B2 9E 03           dw AA51+1-DRIVER_START
0369   41B4 56 00           dw AA52+1-DRIVER_START
0370   41B6             
0371   41B6             
0372   41B6 00 00           dw 0    ; final
0373   41B8             
0374   41B8             
0375   41B8             
0376   41B8             CHECKCOMMA:  ; Z is set when comma seperator found in string, NZ if not, uses A
0377   41B8                 ; BC =0?
0378   41B8 AF              XOR  A
0379   41B9 B9              CP   C
0380   41BA 20 02           JR   NZ,CHKK_CONT
0381   41BC 3C              INC  A ; clear the Z flag
0382   41BD C9              RET     ; no match till end
0383   41BE             CHKK_CONT:
0384   41BE 7E              LD   A, (HL)
0385   41BF FE 1A           CP   26     ; comma
0386   41C1 C8              RET  z
0387   41C2 FE 19           CP   25     ; also check for semicolon
0388   41C4 C8              RET  z
0389   41C5 23              INC  HL
0390   41C6 0B              DEC  BC
0391   41C7 18 EF           JR CHECKCOMMA
0392   41C9             
0393   41C9             
0394   41C9             SKIPEMPTY:  ; Z is set when comma seperator found in string, NZ if not, uses A
0395   41C9                 ; BC =0?
0396   41C9 AF              XOR  A
0397   41CA B9              CP   C
0398   41CB 20 05           JR   NZ,CHKE_CONT
0399   41CD B8              CP   B
0400   41CE 20 02           JR   NZ,CHKE_CONT
0401   41D0 3C              INC  A ; clear the Z flag
0402   41D1 C9              RET     ; no match till end
0403   41D2             CHKE_CONT:
0404   41D2 BE              CP   (HL)
0405   41D3 C0              RET  NZ ; not empty,leave
0406   41D4 23              INC  HL
0407   41D5 0B              DEC  BC
0408   41D6 18 F1           JR SKIPEMPTY
0409   41D8             
0410   41D8             PRINTA:
0411   41D8 E5              PUSH HL
0412   41D9 D5              PUSH DE
0413   41DA C5              PUSH BC
0414   41DB D7              RST 10H
0415   41DC C1              POP  BC
0416   41DD D1              POP  DE
0417   41DE E1              POP  HL
0418   41DF C9              RET
0419   41E0                 
0420   41E0             
0421   41E0             LOAD1: ; both load and dir
0422   41E0             	; HL points to arg string, BC number of chars
0423   41E0 2B              DEC HL  ; back to original CMD - as it coulf be LOAD or DIR
0424   41E1 03              INC BC  ; also transmit CMD char here as we need to distinguish L and D
0425   41E2 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0426   41E3 C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0427   41E4                 ; Check if we have contact
0428   41E4             AA10:    
0429   41E4 CD 73 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0430   41E7 A7              AND A
0431   41E8                 ; Send LOAD request
0432   41E8 C1              POP  BC
0433   41E9 E1              POP  HL ; recover name pointer/length
0434   41EA 28 52           JR   Z, LD_ERR ; NO CONTACT after TRY_HANDSHAKE
0435   41EC E5              PUSH HL  ; and again store for binload
0436   41ED C5              PUSH BC  ; 
0437   41EE             
0438   41EE 41              ld   B,C ; length, assume <256
0439   41EF 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0440   41F1             AA11:
0441   41F1 CD F0 44        CALL SEND_PACKET
0442   41F4             
0443   41F4                 ; now retrieve key, must be 123
0444   41F4             AA12:
0445   41F4 CD C2 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0446   41F7 FE 7B           CP  123
0447   41F9 20 41           JR NZ,LD_ERR2
0448   41FB 06 04           LD   B,4
0449   41FD 7E              LD  A,(HL)  ; dummy for timing
0450   41FE              
0451   41FE             LOADELY1:         ;    //47 delay between the header bytes
0452   41FE 10 FE           DJNZ LOADELY1
0453   4200             
0454   4200                 ; now retrieve length, 0 for error
0455   4200             AA13:
0456   4200 CD C2 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0457   4203 6F              LD   L,A
0458   4204 06 05           LD   B,5
0459   4206             
0460   4206             LOADELY2:         ;    //60 delay between the length bytes
0461   4206 10 FE           DJNZ LOADELY2
0462   4208             
0463   4208 00              NOP
0464   4209             AA14:
0465   4209 CD C2 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0466   420C 67              LD   H,A
0467   420D B5              OR   L
0468   420E 28 2C           JR Z,LD_ERR2
0469   4210 EB              EX   DE,HL
0470   4211                 ; Here we have DE= len
0471   4211                 ; get addr
0472   4211 C1              POP  BC
0473   4212 E1              POP  HL ; recover name pointer/length
0474   4213 D5              PUSH DE             ; length, will go to BC below
0475   4214 D5              PUSH DE             ; length, again, for end result
0476   4215 7E              LD A,(HL) ; check command L or D
0477   4216 FE 29           CP c_D
0478   4218 28 33           JR Z,SHOWDIR
0479   421A 23              INC HL  ; skip cmd
0480   421B 0B              DEC BC
0481   421C                 ;  test if saving binary or regular basic
0482   421C             AA15:
0483   421C CD B8 41        CALL CHECKCOMMA
0484   421F 28 20           JR   Z, BINLOAD
0485   4221             
0486   4221                 ; LOAD BASIC program if not BINLOAD, set addr
0487   4221 21 09 40    	LD HL,4009h		; 
0488   4224 1E 01           LD   E,1        ; mark as basic load
0489   4226             
0490   4226             LOADLOOP:
0491   4226                 ; timing  - 74 between calls seems to be more reliable than 70!
0492   4226             AA16:
0493   4226 CD C2 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0494   4229 77              LD   (HL),A
0495   422A 77              LD   (HL),A ; dummy for timing
0496   422B 23              INC  HL
0497   422C C1              POP  BC     ; get remaining length
0498   422D 0B              DEC  BC
0499   422E 79              LD   A,C
0500   422F B0              OR   B
0501   4230 28 03           JR Z, LD_END
0502   4232 C5              PUSH BC
0503   4233 18 F1           JR  LOADLOOP
0504   4235             LD_END:  
0505   4235 C1              POP  BC ; orig length
0506   4236 AF              XOR  A
0507   4237 BB              CP   E  ; 0 for binary
0508   4238 C8              RET   Z ; normal return for binload with length in BC
0509   4239                 ; end for BASIC loader
0510   4239 D1              POP  DE ; dummy, ret addr
0511   423A CF          	RST 08h ;
0512   423B FF          	db 0FFh
0513   423C             
0514   423C             
0515   423C             LD_ERR2:
0516   423C D1              POP  DE ; dummy
0517   423D D1              POP  DE ; dummy
0518   423E             LD_ERR:
0519   423E 3E 01           LD   A,1
0520   4240 C9              RET ; BC WILL be at maximum now
0521   4241             
0522   4241             
0523   4241             BINLOAD: ; HL points to the comma in arg string, now parse addr, length
0524   4241 23              INC  HL
0525   4242 0D              DEC  C
0526   4243             AA17:
0527   4243 CD 69 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0528   4246 20 F4           JR NZ, LD_ERR2   ; parse error
0529   4248                 ; addr in DE
0530   4248 EB              EX   DE,HL
0531   4249 1E 00           LD   E,0    ; mark as binary
0532   424B 18 D9           JR LOADLOOP
0533   424D             
0534   424D             SHOWDIR:
0535   424D                 ; this is like a binload but into the screen area
0536   424D                 ; first prepare space for it
0537   424D 2A 0C 40        LD HL,(16396) ; D_FILE pos
0538   4250 23              INC HL
0539   4251 22 0E 40        LD (16398),HL  ; restore print position to start of screen as we clean all
0540   4254                 ;XOR A
0541   4254                 ;LD (16441),A      ; PRINT col 24
0542   4254                 ;LD (16442),A      ; PRINT line 33?
0543   4254 EB              EX DE,HL       ; start addr now in DE
0544   4255 2A 10 40        LD HL,(16400)  ; VARS pos as end of screen
0545   4258 2B              DEC HL;        ; leave one byte in there, otherwise pointers will collapse
0546   4259 CD 5D 0A        CALL $A5D      ; reclaim-diff: release mem from DE to HL: CF_CC to VARS-1
0547   425C C1              POP BC         ; get length of new screen
0548   425D C5              PUSH BC        ; put back, needed later 
0549   425E 0B              DEC BC         ; we left one byte already
0550   425F 22 0E 40        LD (16398),HL  ; start from print position
0551   4262 CD 9E 09        CALL $99E      ; make-room: reserve BC bytes at HL
0552   4265 1E 00           LD   E,0       ; from now on it is just a binload, mark
0553   4267 18 BD           JR LOADLOOP    ; 
0554   4269             
0555   4269             
0556   4269             ; parse a decimal number
0557   4269             PARS_DEC_NUM:   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0558   4269 11 00 00    	LD DE, 0
0559   426C AF              XOR  A
0560   426D B9              CP   C
0561   426E 28 35           JR Z,PARSFAIL
0562   4270             
0563   4270             PARS_LLOOP:     ; look for first number
0564   4270 7E          	LD A,(HL)
0565   4271 A7          	AND A
0566   4272 28 29       	JR Z, PARS_SKIPWS ; skip whitespace
0567   4274             PARS_LLP2:
0568   4274 D6 1C       	SUB 01ch	;"0"
0569   4276 38 2D       	JR C,PARSFAIL
0570   4278 FE 0A       	CP 10
0571   427A 30 29       	JR NC,PARSFAIL
0572   427C             	; have a digit in A,
0573   427C E5          	PUSH HL
0574   427D             	; DE times ten
0575   427D 62          	LD H,D      ; now in both HL and DE
0576   427E 6B          	LD L,E
0577   427F 29          	ADD HL,HL
0578   4280 29          	ADD HL,HL
0579   4281 29          	ADD HL,HL ; times 8 so far
0580   4282 19          	ADD HL,DE
0581   4283 19          	ADD HL,DE
0582   4284             	; Add new digit
0583   4284 16 00       	LD D,0
0584   4286 5F          	LD E,A
0585   4287 19          	ADD HL,DE
0586   4288 EB          	EX DE,HL    ; new value of DE
0587   4289 E1          	POP HL  ; pointer to argline back in HL
0588   428A 23          	INC HL
0589   428B 0D          	DEC C
0590   428C 28 15           JR Z,PARSDONE
0591   428E 7E          	LD A,(HL)   ; load next char to see if end
0592   428F FE 1A           CP   26 ;  ','
0593   4291 28 10           JR Z,PARSDONE
0594   4293 FE 0E           CP   14 ;  ';'
0595   4295 28 0C           JR Z,PARSDONE
0596   4297 FE 0B           CP   11 ;  '"'
0597   4299 28 08           JR Z,PARSDONE
0598   429B 18 D7       	JR PARS_LLP2 
0599   429D             PARS_SKIPWS:
0600   429D 23          	INC HL
0601   429E 0D          	DEC C
0602   429F 28 04           JR Z,PARSFAIL
0603   42A1 18 CD       	JR PARS_LLOOP 
0604   42A3             
0605   42A3             PARSDONE:
0606   42A3 AF              XOR  A
0607   42A4 C9          	RET
0608   42A5             PARSFAIL:
0609   42A5 AF              XOR  A
0610   42A6 3C              INC  A
0611   42A7 C9          	RET
0612   42A8             
0613   42A8             
0614   42A8             TESTPATTERN:
0615   42A8             	; HL points to arg string, BC number of chars
0616   42A8 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0617   42A9 C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0618   42AA                 ; Check if we have contact
0619   42AA             AA18:    
0620   42AA CD 73 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0621   42AD A7              AND A
0622   42AE                 ; Send LOAD request
0623   42AE C1              POP  BC
0624   42AF E1              POP  HL ; recover name pointer/length
0625   42B0 28 1C           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0626   42B2             
0627   42B2 41              ld   B,C ; length, assume <256
0628   42B3 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0629   42B5             AA19:
0630   42B5 CD F0 44        CALL SEND_PACKET
0631   42B8             
0632   42B8                 ; now retrieve 1024 bytes and see how many are correct
0633   42B8                 ; gap between byte calls should be 77+12+7 - 17-10 = 69 clocks
0634   42B8 01 00 00        LD   BC,0
0635   42BB             TESTBLOOP:
0636   42BB C5              PUSH BC
0637   42BC 00              NOP         ; timing adjust 66/70
0638   42BD 00              NOP         ; timing adjust 70/74 - 74 seems to be more reliable than 70!
0639   42BE             AA20:
0640   42BE CD C2 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0641   42C1 C1              POP  BC
0642   42C2 B9              CP   C  ; incomming data in A is 0,1,2,3,4...255,0,1... as byte
0643   42C3 3E 00           LD   A,0 ; not affect flags, test never reports errors to better automatize
0644   42C5 C0              RET  NZ ; report BC at point of first failure
0645   42C6 03              INC  BC
0646   42C7 3E 10           LD   A,16 ; 4kbyte testsize
0647   42C9 B8              CP   B
0648   42CA 20 EF           JR   NZ, TESTBLOOP
0649   42CC AF              XOR  A
0650   42CD C9              RET ; BC WILL be at maximum now
0651   42CE             
0652   42CE             
0653   42CE             
0654   42CE             ERREXIT:
0655   42CE 3E 01           LD   A,1
0656   42D0 01 00 00        LD   BC,0
0657   42D3 C9              RET
0658   42D4             
0659   42D4             SAVE1:
0660   42D4             	; HL points to arg string, BC number of chars
0661   42D4 E5              PUSH HL  ; orig pos of args (w/o prefix S)
0662   42D5 C5              PUSH BC  ; orig lenght of args (w/o prefix S)
0663   42D6             
0664   42D6             
0665   42D6             ;    LD   A, c_S
0666   42D6             ;    CALL PRINTA
0667   42D6             
0668   42D6                 ; Check if we have contact
0669   42D6             AA21:   
0670   42D6 CD 73 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0671   42D9                 ; Send SAVE request
0672   42D9 C1              POP  BC
0673   42DA E1              POP  HL ; recover name pointer/length
0674   42DB                 ; evauate connect result
0675   42DB A7              AND A
0676   42DC 28 F0           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0677   42DE             
0678   42DE                 ; again store original argument string, will need it now and when sending name
0679   42DE E5              PUSH HL
0680   42DF C5              PUSH BC
0681   42E0             
0682   42E0                 ;  test if saving binary or regular basic
0683   42E0             AA22:
0684   42E0 CD B8 41        CALL CHECKCOMMA
0685   42E3 28 43           JR   Z, BINSAVE
0686   42E5             
0687   42E5                 ; SAVE BASIC program if not BINSAVE, pre-calc addr,size into HL and BC
0688   42E5 11 09 40    	LD DE,4009h		; Get length
0689   42E8 2A 14 40    	LD HL,(ELINE)	
0690   42EB A7          	AND A		; clear carry
0691   42EC ED 52       	SBC HL,DE	; HL=length
0692   42EE 44          	LD B,H
0693   42EF 4D          	LD C,L
0694   42F0 EB          	EX DE,HL	; Now HL=Start, BC=length
0695   42F1             
0696   42F1             SAVE_CONT: ;continue common path of BIN and BASIC save
0697   42F1 D9              EXX     ; store payload addr and length for now
0698   42F2 EB          	EX DE,HL	; HL' must be restored, save in DE'
0699   42F3 C1              POP  BC
0700   42F4 E1              POP  HL ; recover name pointer/length
0701   42F5             AA23:
0702   42F5 CD C9 41        CALL SKIPEMPTY 
0703   42F8 AF              XOR  A
0704   42F9 B9              CP   C
0705   42FA 28 40           JR   Z, ERREXIT3 ; NO NAME
0706   42FC 41              ld   B,C ; length, assume <256
0707   42FD 0E 5B           ld   C,91 ; packet ID ZX_QSAVE_TAG_SAVEPFILE
0708   42FF             AA24:
0709   42FF CD F0 44        CALL SEND_PACKET
0710   4302 EB          	EX DE,HL	; HL' must be restored, was saved in DE'
0711   4303 D9              EXX ; Recover, now HL=Start, BC=length
0712   4304             	
0713   4304             SVSENDFUL:
0714   4304 AF              XOR  A
0715   4305 B8              CP   B
0716   4306 28 0C           JR   Z, SVSENDLAST
0717   4308                 ; send full packets
0718   4308 C5              PUSH BC
0719   4309 06 00           LD   B,0    ; 256 bytes
0720   430B 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0721   430D             AA25:
0722   430D CD F0 44        CALL SEND_PACKET
0723   4310 C1              POP  BC
0724   4311 05              DEC  B
0725   4312 18 F0           JR   SVSENDFUL
0726   4314             
0727   4314             SVSENDLAST:
0728   4314 AF              XOR  A
0729   4315 B9              CP   C
0730   4316 28 06           JR   Z, SVSENDEND
0731   4318 41              LD   B,C ; length
0732   4319 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0733   431B             AA26:
0734   431B CD F0 44        CALL SEND_PACKET
0735   431E             
0736   431E             SVSENDEND:
0737   431E             AA27:
0738   431E CD A8 44        CALL QS_FINAL_ACK   ; Z set for success
0739   4321 20 AB           JR   NZ, ERREXIT
0740   4323 AF              XOR  A
0741   4324 01 01 00        LD   BC, 1
0742   4327 C9          	RET
0743   4328             
0744   4328             
0745   4328             BINSAVE: ; HL points to the comma in arg string, now parse addr, length
0746   4328 23              INC  HL
0747   4329 0D              DEC  C
0748   432A             AA28:
0749   432A CD 69 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0750   432D 20 13           JR NZ, BSERREXIT   ; parse error
0751   432F D5              PUSH DE ; store addr, from now on have to use BSERREXIT2 to stack-unwind here
0752   4330 23              INC  HL
0753   4331 0D              DEC  C
0754   4332             AA29:
0755   4332 CD 69 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0756   4335 20 0A           JR NZ, BSERREXIT2   ; parse error
0757   4337                 ; length in DE
0758   4337                 ; Now put HL=Start, BC=length
0759   4337 42              LD   B,D
0760   4338 4B              LD   C,E
0761   4339 E1              POP  HL
0762   433A 18 B5           JR SAVE_CONT
0763   433C             
0764   433C             ERREXIT3:
0765   433C EB          	EX DE,HL	; HL' must be restored, saved in DE'
0766   433D D9              EXX ; Recover
0767   433E 3E 01           LD   A,1
0768   4340 C9          	RET
0769   4341             
0770   4341             BSERREXIT2:
0771   4341 D1              POP  DE
0772   4342             BSERREXIT:
0773   4342 C1              POP  BC
0774   4343 E1              POP  HL ; recover name pointer/length
0775   4344 3E 01           LD   A,1
0776   4346 C9          	RET
0777   4347             
0778   4347             
0779   4347             HLPTXT1:
0780   4347 3F 3D 00 3C 	db c_Z,c_X,0,c_W,c_E,c_S,c_P,c_I,0,c_D,c_R,c_I,c_V,c_E,c_R,c_NEWLINE
0780   434B 2A 38 35 2E 
0780   434F 00 29 37 2E 
0780   4353 3B 2A 37 76 
0781   4357 76 76           db c_NEWLINE,c_NEWLINE
0782   4359 35 37 2E 33 	db c_P,c_R,c_I,c_N,c_T, 0 , c_U, c_S, c_R, 0 
0782   435D 39 00 3A 38 
0782   4361 37 00 
0783   4363 FF          	db $ff
0784   4364             
0785   4364             ;	db "INFO  ",22h,"I",22h,0dh
0786   4364             ;	db "DIR   ",22h,"D",22h,0dh
0787   4364             ;	db "ERASE ",22h,"ENAME.P",22h,0dh
0788   4364             ;	db "MKDIR ",22h,"DMVERZ",22h,0dh
0789   4364             ;	db "RMDIR ",22h,"DEVERZ",22h,0dh
0790   4364             ;	db "CHDIR ",22h,"DCVERZ",22h,0dh
0791   4364             HLPTXT2:
0792   4364 1A 0B 13 28 	db 26, 11, 19, c_C,c_M,c_D, 18,  11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0792   4368 32 29 12 0B 
0792   436C 76 
0793   436D 76 76           db c_NEWLINE,c_NEWLINE
0794   436F 31 34 26 29 	db c_L,c_O,c_A,c_D, 0 , 0 , 0, 11, c_L, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0794   4373 00 00 00 0B 
0794   4377 31 33 26 32 
0794   437B 2A 0B 76 
0795   437E 38 26 3B 2A 	db c_S,c_A,c_V,c_E, 0 , 0 , 0, 11, c_S, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0795   4382 00 00 00 0B 
0795   4386 38 33 26 32 
0795   438A 2A 0B 76 
0796   438D 27 31 34 26 	db c_B,c_L,c_O,c_A,c_D, 0 , 0, 11, c_L, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 11,c_NEWLINE   ; "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0796   4391 29 00 00 0B 
0796   4395 31 33 26 32 
0796   4399 2A 1A 26 29 
0796   439D 29 37 0B 76 
0797   43A1 27 38 26 3B 	db c_B,c_S,c_A,c_V,c_E, 0 , 0, 11, c_S, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 26, c_L, c_E, c_N,  11,c_NEWLINE   ; "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0797   43A5 2A 00 00 0B 
0797   43A9 38 33 26 32 
0797   43AD 2A 1A 26 29 
0797   43B1 29 37 1A 31 
0797   43B5 2A 33 0B 76 
0798   43B9 29 2E 37 00 	db c_D,c_I,c_R,  0, 0 , 0 , 0, 11, c_D, 11, 0, c_O, c_R, 0, 11, c_D,0, c_P, c_A, c_G, c_E, 11,     ,c_NEWLINE   ;  c_H,   "DIR  ",22h,"H",22h,0dh
0798   43BD 00 00 00 0B 
0798   43C1 29 0B 00 34 
0798   43C5 37 00 0B 29 
0798   43C9 00 35 26 2C 
0798   43CD 2A 0B 00 76 
0799   43D1 2D 2A 31 35 	db c_H,c_E,c_L,c_P, 0 , 0 , 0, 11, c_H, 11,c_NEWLINE   ;  c_H,   "HELP  ",22h,"H",22h,0dh
0799   43D5 00 00 00 0B 
0799   43D9 2D 0B 76 
0800   43DC             ;	db "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0801   43DC             ;	db "RENAME",22h,"ROLDNAME NEWNAME",22h,0dh
0802   43DC 76              db c_NEWLINE
0803   43DD 2E 33 38 39 	db c_I,c_N,c_S,c_T,c_A,c_L,c_L, 0 , c_D,c_R,c_V, 0 ,c_T,c_O, 0, c_R,c_A,c_M,  0, 11, c_I, 0, c_A, c_D, c_D, c_R,  11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0803   43E1 26 31 31 00 
0803   43E5 29 37 3B 00 
0803   43E9 39 34 00 37 
0803   43ED 26 32 00 0B 
0803   43F1 2E 00 26 29 
0803   43F5 29 37 0B 76 
0804   43F9             ;	db c_T,c_E,c_S,c_T, 0 , 0 , 0, 11, c_T, c_L, c_T, c_T, c_T, c_0+2, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0805   43F9             ;	db "FOR SIGGI'S UFM :V/R/K",0dh
0806   43F9 76              db c_NEWLINE
0807   43FA 76              db c_NEWLINE
0808   43FB 37 2A 3B 00     db c_R, c_E, c_V, 0, c_A, c_0+2,0,0,0, c_S, c_I, c_Z, c_E, 0
0808   43FF 26 1E 00 00 
0808   4403 00 38 2E 3F 
0808   4407 2A 00 
0809   4409 FF          	db $ff
0810   440A             
0811   440A             
0812   440A             ; === Subroutine print help text ====
0813   440A             AA08:
0814   440A             HLP:
0815   440A 21 47 43    	LD HL,HLPTXT1
0816   440D             AA46:
0817   440D CD 27 44        CALL PRINTTEXT
0818   4410             AA47:
0819   4410 21 82 40    	LD HL,DRIVER_START
0820   4413             AA48:
0821   4413 CD 2F 44        CALL PRINTBASE10
0822   4416             AA49:
0823   4416 21 64 43    	LD HL,HLPTXT2
0824   4419             AA50:
0825   4419 CD 27 44        CALL PRINTTEXT
0826   441C 21 21 05        LD HL,DRIVER_END-DRIVER_START
0827   441F             AA51:
0828   441F CD 2F 44        CALL PRINTBASE10
0829   4422 01 2A 00        LD   BC,42
0830   4425 AF              XOR  A
0831   4426 C9              RET
0832   4427             
0833   4427             ; Text in HL, FF marks end
0834   4427             PRINTTEXT:
0835   4427 7E          	LD A,(HL)
0836   4428 FE FF       	CP $FF
0837   442A C8          	RET Z
0838   442B D7              RST 10H
0839   442C 23          	INC HL
0840   442D 18 F8       	JR PRINTTEXT
0841   442F             
0842   442F             
0843   442F             ; *
0844   442F             ; * PRINT HL DECIMAL
0845   442F             ; *
0846   442F             PRINTBASE10:
0847   442F E5          	PUSH HL
0848   4430 C5          	PUSH BC
0849   4431 D5          	PUSH DE
0850   4432 AF              XOR A
0851   4433 F5          	PUSH AF
0852   4434             _PRTLP:
0853   4434             _DIV10: ; * HL=HL/10 A=REMAINDE
0854   4434 06 10       	LD B,10h
0855   4436 AF          	XOR A
0856   4437             _DIVLP:
0857   4437 CB 25       	SLA L
0858   4439 CB 14       	RL H
0859   443B 17          	RLA
0860   443C FE 0A       	CP 0Ah
0861   443E 38 04       	JR C,_SK
0862   4440 CB C5       	SET 0,L
0863   4442 D6 0A       	SUB 0Ah
0864   4444             _SK:
0865   4444 10 F1       	DJNZ _DIVLP
0866   4446             
0867   4446 C6 1C       	ADD A,1CH
0868   4448 F5          	PUSH AF
0869   4449 7C          	LD A,H
0870   444A B5          	OR L
0871   444B 20 E7       	JR NZ,_PRTLP
0872   444D             _PRTL1:
0873   444D F1          	POP AF
0874   444E B7          	OR A
0875   444F 20 04       	JR NZ,_PRT2
0876   4451 D1          	POP DE
0877   4452 C1          	POP BC
0878   4453 E1          	POP HL
0879   4454 C9          	RET
0880   4455             _PRT2
0881   4455 D7          	RST 10H
0882   4456 18 F5       	JR _PRTL1
0883   4458             
0884   4458             
0885   4458             
0886   4458             GO_QSAVE_MODE:
0887   4458 CD E7 02    	CALL FAST	; go to fast mode
0888   445B DB FE           IN      A,($FE)         ; signal to 0 pause    
0889   445D 06 C8           LD B,200  ; 200=200ms Pause
0890   445F C5          W1: push BC
0891   4460 06 00           ld b,0
0892   4462             W2:
0893   4462 10 FE           djnz W2     ; 1 millisec (256*4)
0894   4464 C1              pop BC
0895   4465 10 F8           djnz W1
0896   4467 1E 4B           LD E, 75    ; ID for ZX_SAVE_TAG_QSAVE_START
0897   4469 CD 1F 03        CALL $031F  ; SAVE byte in E
0898   446C D3 FF           OUT     ($FF),A         ; ; signal to 1 / syncoff, send hsyncs
0899   446E 06 00           ld b,0
0900   4470             W4:
0901   4470 10 FE           djnz W4     ; 1 millisec (256*4) to go to QSAVE mode
0902   4472 C9              RET
0903   4473             
0904   4473             TRY_HANDSHAKE:  ; See if WESPI responds, return 1 if so, 0 for timeout
0905   4473             AA30:
0906   4473 CD 58 44        CALL GO_QSAVE_MODE
0907   4476 21 04 40        ld   hl, 16388 ; RAMTOP
0908   4479 06 02           ld   B,2
0909   447B 0E 5A           ld   C,90 ; packet ID ZX_QSAVE_TAG_HANDSHAKE
0910   447D             AA31:
0911   447D CD F0 44        CALL SEND_PACKET
0912   4480 06 B5           ld   b,181  ; timeout, 500ms (inner loop 3.15ms)
0913   4482             HS_LOOP1:
0914   4482 C5              PUSH BC
0915   4483 06 00           LD   B,0
0916   4485             HS_LOOP2:                  ; 35 cycles=10.7us, inner Loop 2.75 millisec
0917   4485 DB FE           in a,($FE)  ; 11
0918   4487 17              rla         ; 4
0919   4488 38 0E           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0920   448A 10 F9           DJNZ HS_LOOP2 ;13
0921   448C                 ; re-check here to not have a blind spot for outer loop
0922   448C DB FE           in a,($FE)  ; 11
0923   448E 17              rla         ; 4
0924   448F 38 07           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0925   4491 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff in between to not let levels drift (not good for follow-up cmds?)
0926   4493 C1              POP  BC
0927   4494 10 EC           DJNZ HS_LOOP1
0928   4496                 ; no signal found
0929   4496 AF              XOR  A
0930   4497 C9              RET
0931   4498             
0932   4498             HS_FOUND
0933   4498 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0934   449A                 ; let the output recover with active signal after being low from input. takes about 1ms as seen in oscilloscope
0935   449A 06 00           LD   B,0
0936   449C             HS_FINALDELAY: ; 3ms here before next cmd
0937   449C 7E              LD   A,(HL)
0938   449D 7E              LD   A,(HL)
0939   449E 7E              LD   A,(HL)    
0940   449F 7E              LD   A,(HL)    
0941   44A0 10 FA           DJNZ HS_FINALDELAY
0942   44A2 C1              POP  BC
0943   44A3 3E 01           LD   A,1
0944   44A5 A7              AND  A
0945   44A6 C9              RET
0946   44A7             
0947   44A7             QS_FINAL_SZ:
0948   44A7 00              db 0 ; size of return packet to request, use smallest possible
0949   44A8             
0950   44A8             QS_FINAL_ACK:  ; Get info is operation was sussessful (Z) or failed (NZ), USES BC DE HL, A
0951   44A8 21 A7 44        ld   hl, QS_FINAL_SZ ; Requested length
0952   44AB 06 01           ld   B,1
0953   44AD 0E 63           LD   C,99 ; packet ID ZX_QSAVE_TAG_END_RQ
0954   44AF             AA32:
0955   44AF CD F0 44        CALL SEND_PACKET
0956   44B2             
0957   44B2                 ; await reply, first byte is tag, then result
0958   44B2             AA33:
0959   44B2 CD C2 44        CALL QLD_GETBYTE
0960   44B5 FE 2A           CP   42 ; tag
0961   44B7 C0              RET  NZ
0962   44B8 06 08           ld B,8  ; 
0963   44BA             QSFDLY:
0964   44BA 10 0F           djnz lgapdly     ; 13*n-5 = 47 for 4
0965   44BC             AA34:
0966   44BC CD C2 44        CALL QLD_GETBYTE
0967   44BF FE 01           CP   1 ; result
0968   44C1 C9              RET    ; Z on match
0969   44C2             
0970   44C2             
0971   44C2             
0972   44C2             ; gab between byte calls should be 77+12+7 - 17-10 = 69 clocks
0973   44C2             
0974   44C2             QLD_GETBYTE:    ; uses BC D, result in A
0975   44C2 0E FE           ld c,$fe   ; 7
0976   44C4 06 08           ld b,8  ; 7    for gap between start and bits
0977   44C6             
0978   44C6             lwt_stdly:                  ; 25 cycles=7.7us
0979   44C6 DB FE           in a,($FE)  ; 11
0980   44C8 17              rla         ; 4
0981   44C9 30 FB           jr nc,lwt_stdly ; 12 / 7  (D7=0 is low level, wait for high)
0982   44CB                 ; trigger is seen 4us too late in average, so wait 48-4 - 4 us now: 130 cy in-in
0983   44CB             lgapdly:
0984   44CB 10 FE           djnz lgapdly     ; 13*n-5 = 99 for 8
0985   44CD 06 08           ld b,8  ; 7
0986   44CF             lbloop:                 ;  need 104 for 32us
0987   44CF ED 50           in d,(c)    ; 12
0988   44D1 CB 12           rl d        ; 8
0989   44D3 17              rla         ; 4 (rl a is 8)
0990   44D4 16 04           ld d,4      ; 7
0991   44D6             lbdly:
0992   44D6 15              dec d          ; 4          b*16-5 = 59
0993   44D7 20 FD           jr nz,lbdly     ; 12 / 7
0994   44D9 10 F4           djnz lbloop     ; 13 / 8
0995   44DB C9              RET     
0996   44DC                 
0997   44DC                 ;ORIGINAL:
0998   44DC                 ;ld (hl),a   ; 7
0999   44DC             	;CALL UPDATE  ; will use DE, inc HL    77 clks
1000   44DC                 ;jr lwt_start     ; 12
1001   44DC             
1002   44DC             
1003   44DC             
1004   44DC             
1005   44DC             ;*
1006   44DC             ;* Evaluate string  start of the string is in HL and the length in BC
1007   44DC             ;*
1008   44DC E7          NAME:	RST 20h
1009   44DD CD 55 0F    	CALL 0F55h ; evaluate
1010   44E0 3A 01 40    	LD A,(4001h)
1011   44E3 87          	ADD A,A
1012   44E4 FA 9A 0D    	JP M,0D9Ah  ; error
1013   44E7 E1          	POP HL
1014   44E8 D0          	RET NC
1015   44E9 E5          	PUSH HL
1016   44EA CD F8 13    	CALL 13F8h ; get indexvar fom calc stack STK-FETCH
1017   44ED                 ; For strings, the start of the string is in DE and the length in BC
1018   44ED 62          	LD H,D
1019   44EE 6B          	LD L,E
1020   44EF C9          	RET
1021   44F0             
1022   44F0             
1023   44F0             SEND_PACKET: ; HL points to data, C holds type, B lenght (0=256bytes), HL will point behind sent data afterwards
1024   44F0 F5              PUSH AF
1025   44F1 C5              PUSH BC ; BC needed twice, for header, and recovered at end
1026   44F2 C5              PUSH BC
1027   44F3             
1028   44F3 06 E1           LD B,225    ;   TODO 125 should be enough
1029   44F5             SPWT:
1030   44F5 10 FE           djnz SPWT     ; 500 microsec  (125*4)  ; let the video lines sync again, require 5 lines (320), some margin added
1031   44F7             
1032   44F7                 ; we want all our pulses in sync with the HSYNC pulses to not interfere   
1033   44F7 AF              XOR A       ; make sure A' not at sync or display position to
1034   44F8 08              EX AF,AF'   ; just cause short INT on MNI here:
1035   44F9                             
1036   44F9 D3 FE           OUT ($FE),A  ; ENABLE NMI
1037   44FB 76              HALT
1038   44FC D3 FD           OUT ($FD),A  ; Disable NMI   from here, start first bit in 54us =174cy
1039   44FE DB FE           IN      A,($FE)         ; signal to 0 /on - syncout
1040   4500 7E              LD   A,(HL)     ; 7 dummy 
1041   4501 00              NOP             ; 4
1042   4502 06 07           LD   B,7
1043   4504 00              NOP             ; timing adjust to have bits symmetrical in (black-shouldered) line
1044   4505 D3 FF           OUT     ($FF),A ;11        ; signal to 1 / syncoff
1045   4507             waitnline:
1046   4507 10 FE           DJNZ waitnline          ; delay for next line 13 per loop ..
1047   4509 C1              POP  BC            ;10
1048   450A             
1049   450A             
1050   450A                 ; Send packettype in C
1051   450A             AA35:
1052   450A CD 50 45        CALL SENDNIBBLE ;151, so we need 56 cycles between nibbles to get to 207 for one hsync line
1053   450D             
1054   450D 23              INC  HL         ; 6  ; DUMMY matching later dec
1055   450E 7E              LD   A,(HL)     ; 7 
1056   450F D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1057   4511 7E              LD   A,(HL)     ; 7 
1058   4512 7E              LD   A,(HL)     ; 7 
1059   4513 7E              LD   A,(HL)     ; 7 
1060   4514 7E              LD   A,(HL)     ; 7 
1061   4515 00              NOP
1062   4516             AA36:
1063   4516 CD 50 45        CALL SENDNIBBLE ;151
1064   4519             
1065   4519 2B              DEC  HL 
1066   451A 7E              LD   A,(HL)     ; 7 
1067   451B D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
1068   451D 7E              LD   A,(HL)     ; 7 
1069   451E 7E              LD   A,(HL)     ; 7 
1070   451F 7E              LD   A,(HL)     ; 7 
1071   4520 7E              LD   A,(HL)     ; 7 
1072   4521 48              LD C,B             ;4
1073   4522             
1074   4522                 ; Send length in B
1075   4522             AA37:
1076   4522 CD 50 45        CALL SENDNIBBLE ;151
1077   4525             
1078   4525 23              INC  HL         ; 6  ; DUMMY matching later dec
1079   4526 7E              LD   A,(HL)     ; 7 
1080   4527 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1081   4529 7E              LD   A,(HL)     ; 7 
1082   452A 7E              LD   A,(HL)     ; 7 
1083   452B 7E              LD   A,(HL)     ; 7 
1084   452C 7E              LD   A,(HL)     ; 7 
1085   452D 00              NOP             ; 4
1086   452E             AA38:
1087   452E CD 50 45        call SENDNIBBLE ;151
1088   4531             
1089   4531 2B              DEC  HL 
1090   4532 7E              LD   A,(HL)     ; 7 
1091   4533             byteloop:
1092   4533 D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
1093   4535 7E              LD   A,(HL)     ; 7 
1094   4536 7E              LD   A,(HL)     ; 7 
1095   4537 7E              LD   A,(HL)     ; 7 
1096   4538 4E              LD   C,(HL)     ; 7 
1097   4539 00              NOP
1098   453A             AA39:
1099   453A CD 50 45        call SENDNIBBLE ;151
1100   453D 23              INC  HL         ; 6
1101   453E 7E              LD   A,(HL)     ; 7 
1102   453F D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1103   4541 7E              LD   A,(HL)     ; 7 
1104   4542 7E              LD   A,(HL)     ; 7 
1105   4543 7E              LD   A,(HL)     ; 7 
1106   4544 7E              LD   A,(HL)     ; 7 
1107   4545 00              NOP
1108   4546                                 ; 56
1109   4546             AA40:    
1110   4546 CD 50 45        CALL SENDNIBBLE ;151
1111   4549 10 E8           DJNZ byteloop   ; 13
1112   454B D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1113   454D             
1114   454D C1              POP  BC
1115   454E F1              POP  AF
1116   454F C9              ret
1117   4550             
1118   4550             
1119   4550             SENDNIBBLE: ;31 per bit, 134 incl RET 151 incl call, nibble in C lower half
1120   4550                 ; Four bits to send
1121   4550                 ;# bit 1 start
1122   4550 CB 01           RLC C       ; 8
1123   4552 38 19           JR C, csendH1 ; 12/7
1124   4554 D8              ret c        ; 11/5 dummy for symmetric timing
1125   4555                 ;# bit 1 send 0
1126   4555 DB FE           IN      A,($FE)         ; signal to 0 /on
1127   4557             
1128   4557                 ;# bit 2 start
1129   4557 CB 01           RLC C       ; 8
1130   4559 38 2A           JR C, csendH2 ; 12/7
1131   455B D8              ret c        ; 11/5 dummy for symmetric timing
1132   455C                 ;# bit 2 send 0
1133   455C DB FE           IN      A,($FE)         ; signal to 0 /on
1134   455E             
1135   455E                 ;# bit 3 start
1136   455E CB 01           RLC C       ; 8
1137   4560 38 34           JR C, csendH3 ; 12/7
1138   4562 D8              ret c        ; 11/5 dummy for symmetric timing
1139   4563                 ;# bit 3 send 0
1140   4563 DB FE           IN      A,($FE)         ; signal to 0 /on
1141   4565             
1142   4565                 ;# bit 4 start
1143   4565 CB 01           RLC C       ; 8
1144   4567 38 37           JR C, csendH4 ; 12/7
1145   4569 D8              ret c        ; 11/5 dummy for symmetric timing
1146   456A                 ;# bit 4 send 0
1147   456A DB FE           IN      A,($FE)         ; signal to 0 /on
1148   456C             
1149   456C C9              ret
1150   456D             
1151   456D             
1152   456D             csendH1:    ;# bit 1 send 1
1153   456D D3 FF           OUT     ($FF),A         ; signal to 1 /off
1154   456F             
1155   456F                 ;# bit 2 start
1156   456F CB 01           RLC C       ; 8
1157   4571 38 12           JR C, csendH2 ; 12/7
1158   4573 D8              ret c        ; 11/5 dummy for symmetric timing
1159   4574                 ;# bit 2 send 0
1160   4574 DB FE           IN      A,($FE)         ; signal to 0 /on
1161   4576             
1162   4576                 ;# bit 3 start
1163   4576 CB 01           RLC C       ; 8
1164   4578 38 1C           JR C, csendH3 ; 12/7
1165   457A D8              ret c        ; 11/5 dummy for symmetric timing
1166   457B                 ;# bit 3 send 0
1167   457B DB FE           IN      A,($FE)         ; signal to 0 /on
1168   457D             
1169   457D                 ;# bit 4 start
1170   457D CB 01           RLC C       ; 8
1171   457F 38 1F           JR C, csendH4 ; 12/7
1172   4581 D8              ret c        ; 11/5 dummy for symmetric timing
1173   4582                 ;# bit 4 send 0
1174   4582 DB FE           IN      A,($FE)         ; signal to 0 /on
1175   4584 C9              ret
1176   4585             
1177   4585             csendH2:    ;# bit 2 send 1
1178   4585 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1179   4587             
1180   4587                 ;# bit 3 start
1181   4587 CB 01           RLC C       ; 8
1182   4589 38 0B           JR C, csendH3 ; 12/7
1183   458B D8              ret c        ; 11/5 dummy for symmetric timing
1184   458C                 ;# bit 3 send 0
1185   458C DB FE           IN      A,($FE)         ; signal to 0 /on
1186   458E             
1187   458E                 ;# bit 4 start
1188   458E CB 01           RLC C       ; 8
1189   4590 38 0E           JR C, csendH4 ; 12/7
1190   4592 D8              ret c        ; 11/5 dummy for symmetric timing
1191   4593                 ;# bit 4 send 0
1192   4593 DB FE           IN      A,($FE)         ; signal to 0 /on
1193   4595 C9              ret
1194   4596             
1195   4596             csendH3:    ;# bit 3 send 1
1196   4596 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1197   4598             
1198   4598                 ;# bit 4 start
1199   4598 CB 01           RLC C       ; 8
1200   459A 38 04           JR C, csendH4 ; 12/7
1201   459C D8              ret c        ; 11/5 dummy for symmetric timing
1202   459D                 ;# bit 4 send 0
1203   459D DB FE           IN      A,($FE)         ; signal to 0 /on
1204   459F C9              ret
1205   45A0             
1206   45A0             csendH4:    ;# bit 4 send 1
1207   45A0 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1208   45A2 C9              ret
1209   45A3             
1210   45A3             DRIVER_END:
1211   45A3             
1212   45A3 76             db $76   ;N/L 
1213   45A4             
1214   45A4             line10:
1215   45A4 00 0A          db 0,10  ;line number 
1216   45A6 13 00          dw dfile-$-2  ;line length 
1217   45A8 F5             db $f5   ;PRINT 
1218   45A9 D4             db $d4   ;USR 
1219   45AA 1D             db $1d   ;1 
1220   45AB 22             db $22   ;6 
1221   45AC 21             db $21   ;5 
1222   45AD 1D             db $1d   ;1 
1223   45AE 20             db $20   ;4 
1224   45AF 7E             db $7e   ;FP mark 
1225   45B0 8F             db $8f   ;5 bytes FP number 
1226   45B1 01             db $01   ; 
1227   45B2 04             db $04   ; 
1228   45B3 00             db $00   ; 
1229   45B4 00             db $00   ; 
1230   45B5 1A             db $1a   ; ,
1231   45B6 0B             db $0b   ; "
1232   45B7 2D             db c_H   ; Help
1233   45B8              ;  db c_D   ; Dir
1234   45B8             
1235   45B8              ;  db c_I   ; I 10000 install
1236   45B8                ;db c_I   ; TTTT2 = QLOAD test
1237   45B8                ;db c_T   ; SNNN = dummy save for testing
1238   45B8                ;db c_S   ; STST,1024,100 binsave
1239   45B8                ;db c_T   ; LTST,1024   binload
1240   45B8              ;  db 0   ; 
1241   45B8              ;  db c_0+1   ; 
1242   45B8              ;  db c_0+0   ; 
1243   45B8              ;  db c_0+0   ; 
1244   45B8              ;  db c_0+0   ; 
1245   45B8              ;  db c_0+0   ; 
1246   45B8             ;   db 26
1247   45B8             ;   db c_0+1   ; 
1248   45B8             ;   db c_0+0   ; 
1249   45B8             ;   db c_0+0   ; 
1250   45B8 0B             db $0b   ; "
1251   45B9 76             db $76   ;N/L 
1252   45BA 76             db $76   ;N/L 
1253   45BB             
1254   45BB             
1255   45BB                
1256   45BB             ;- Display file -------------------------------------------- 
1257   45BB              
1258   45BB             dfile: 
1259   45BB 76             db $76 
1260   45BC 3F 3D          db c_Z,c_X,
1261   45BE 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1261   45C2 76 76 76 76 
1262   45C6 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1262   45CA 76 76 76 76 
1263   45CE 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1263   45D2 76 76 76 76 
1264   45D6              
1265   45D6             ;- BASIC-Variables ---------------------------------------- 
1266   45D6              
1267   45D6             var: 
1268   45D6 80             db $80 
1269   45D7              
1270   45D7             ;- End of program area ---------------------------- 
1271   45D7             
1272   45D7             last: 
1273   45D7              
1274   45D7                end 
tasm: Number of errors = 0
