0001   0000             ; SYSINFO81 
0002   0000             ; 	GPL
0003   0000             ; 	Oliver Lange
0004   0000             ; 	Version 1.0.1
0005   0000             
0006   0000             ; Compile with "tasm -80 -b wspdrv.asm wspdrv.p" 
0007   0000             
0008   0000             
0009   0000             ; driver for wespi
0010   0000             ;
0011   0000             
0012   0000             
0013   0000              
0014   0000             #define db .byte ;  cross-assembler definitions 
0015   0000             #define dw .word 
0016   0000             #define ds .block 
0017   0000             #define org .org 
0018   0000             #define end .end 
0019   0000             
0020   0000             
0021   0000             
0022   0000             #define ADDR_DISABLE 0
0023   0000             #define UPDATE	01FCh	; LOAD/SAVE adress update subroutine in ROM
0024   0000             
0025   0000             ;;#define VERBOSE 1
0026   0000              
0027   4009             org     $4009 ; BASIC PROGRAMM
0028   4009             ;= System variables ============================================ 
0029   4009              
0030   4009 00             db 0     	;VERSN 
0031   400A 00 00          dw 0     	;E_PPC 
0032   400C 7B 45          dw dfile      ;D_FILE 
0033   400E 7C 45          dw dfile+1    ;DF_CC 
0034   4010 96 45          dw var   	;VARS 
0035   4012 00 00          dw 0     	;DEST 
0036   4014 97 45          dw var+1      ;E_LINE 
0037   4016 96 45          dw last-1     ;c_ADD 
0038   4018 00 00          dw 0     	;X_PTR 
0039   401A 97 45          dw last  	;STKBOT 
0040   401C 97 45          dw last  	;STKEND 
0041   401E 00             db 0     	;BERG 
0042   401F 5D 40          dw membot     ;MEM 
0043   4021 00             db 0     ;not used 
0044   4022 02             db 2     ;DF_SZ 
0045   4023 01 00          dw 1     ;S_TOP 
0046   4025 FF FF FF       db $FF,$FF,$FF     ;LAST_K 
0047   4028 37             db 55    ;MARGIN 
0048   4029 64 45          dw line10     ;NXTLIN   line10   dfile
0049   402B 00 00          dw 0     ;OLDPPC 
0050   402D 00             db 0     ;FLAGX 
0051   402E 00 00          dw 0     ;STRLEN 
0052   4030 8D 0C          dw $0C8D      ;T_ADDR 
0053   4032 00 00          dw 0     ;SEED 
0054   4034 FF FF          dw $FFFF      ;FRAMES 
0055   4036 00 00          db 0,0   ;COORDS 
0056   4038 BC             db $BC   ;PR_CC 
0057   4039 21 18          db 33,24      ;S_POSN 
0058   403B 40             db 01000000B  ;CDFLAG 
0059   403C                ds 33    ;Print buffer --- now used for loader code, all loaded programs need to have the same !
0060   405D             
0061   405D             membot: 
0062   405D                ds 30    ;Calculator�s memory area 
0063   407B                ds 2     ;not used 
0064   407D              
0065   407D             ;= First BASIC line, asm code ================================== 
0066   407D              
0067   407D             line0: 
0068   407D 00 00          db 0,0   ;line number 
0069   407F E3 04          dw line10-$-2 ;line length 
0070   4081 EA             db $ea   ; REM 
0071   4082             
0072   4082             
0073   4082             #define ELINE	4014h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0074   4082             #define ELINEHI	4015h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0075   4082             
0076   4082             #define SHOW	0207h  ; ROM-Routinen
0077   4082             #define FAST	02E7h
0078   4082             #define RCLS	0A2Ah
0079   4082             #define GETKEY	02BBh
0080   4082             
0081   4082             
0082   4082             #DEFINE RST_PRTCHAR RST 10H
0083   4082             #DEFINE c_SPACE 0
0084   4082             #DEFINE c_NEWLINE 76H
0085   4082             #DEFINE c_0 1CH
0086   4082             
0087   4082             #DEFINE c_A 26H
0088   4082             #DEFINE c_B c_A+1
0089   4082             #DEFINE c_C c_A+2
0090   4082             #DEFINE c_D c_A+3
0091   4082             #DEFINE c_E c_A+4
0092   4082             #DEFINE c_F c_A+5
0093   4082             #DEFINE c_G c_A+6
0094   4082             #DEFINE c_H c_A+7
0095   4082             #DEFINE c_I c_A+8
0096   4082             #DEFINE c_J c_A+9
0097   4082             #DEFINE c_K c_J+1
0098   4082             #DEFINE c_L c_J+2
0099   4082             #DEFINE c_M c_J+3
0100   4082             #DEFINE c_N c_J+4
0101   4082             #DEFINE c_O c_J+5
0102   4082             #DEFINE c_P c_J+6
0103   4082             #DEFINE c_Q c_J+7
0104   4082             #DEFINE c_R c_J+8
0105   4082             #DEFINE c_S c_J+9
0106   4082             #DEFINE c_T c_S+1
0107   4082             #DEFINE c_U c_S+2
0108   4082             #DEFINE c_V c_S+3
0109   4082             #DEFINE c_W c_S+4
0110   4082             #DEFINE c_X c_S+5
0111   4082             #DEFINE c_Y c_S+6
0112   4082             #DEFINE c_Z c_S+7
0113   4082             
0114   4082             #define UFM_ERRNO 16434 ; Definiert in UFM, Fehlercode 1 Byte (eigentlich SEED)
0115   4082             #define UFM_CMDBUF 16444 ; Definiert in UFM, 32 Byte, alternative Kommando�bergabe (eigentlich PRBUF)
0116   4082             #define UFM_COORDS 16438 ; L�ngen�bergabe 2 Byte (eigentlich COORDS)
0117   4082             
0118   4082             
0119   4082             ;
0120   4082             ;   === Main entry point ====
0121   4082             ;
0122   4082             DRIVER_START:
0123   4082             BASIC_START:
0124   4082             AA45:
0125   4082 CD 9C 44    	CALL NAME	; get command line arg
0126   4085 18 1B       	JR BASIC_CONT
0127   4087 00          	NOP
0128   4088 00          	NOP
0129   4089 00          	NOP
0130   408A             
0131   408A             CALL_START:	; (IN UFM als START_ADDR+6 festgelegt)
0132   408A 21 3C 40    	LD HL,UFM_CMDBUF
0133   408D E5              PUSH HL
0134   408E                 ;  get length in BC by parsing for '"' or so..
0135   408E 01 00 00        LD   BC,0
0136   4091             ENDPRSLP:
0137   4091 7E              LD   A,(HL)
0138   4092 FE 0B           CP   11     ; is " ?
0139   4094 28 04           JR   Z, EXITPRSLP
0140   4096 03              INC  BC
0141   4097 23              INC  HL
0142   4098 18 F7           JR   ENDPRSLP
0143   409A             EXITPRSLP:
0144   409A E1              POP  HL ; original pointer
0145   409B             AA44:
0146   409B CD BA 40    	CALL GENER_START
0147   409E 32 32 40    	LD (UFM_ERRNO),A
0148   40A1 C9          	RET
0149   40A2             
0150   40A2             BASIC_CONT:
0151   40A2             AA01:
0152   40A2 CD BA 40    	CALL GENER_START ; A is 0 for ok, !=0 for error
0153   40A5 A7          	AND A
0154   40A6 28 0F       	JR Z,BAS_OK
0155   40A8 3E 2A       	LD A,c_E		; Ausgabe ERR
0156   40AA D7          	RST 10h 
0157   40AB 3E 37       	LD A,c_R
0158   40AD D7          	RST 10h
0159   40AE 3E 37           LD A,c_R
0160   40B0 D7          	RST 10h
0161   40B1 3E 76           LD A,c_NEWLINE
0162   40B3 D7          	RST 10h
0163   40B4                 ; exit
0164   40B4 AF              XOR A
0165   40B5 CF          	RST 08h
0166   40B6 09              db  09h             ; Error Report: Invalid argument
0167   40B7             	;db 0FFh
0168   40B7             
0169   40B7             BAS_OK:
0170   40B7             	; RET  ; TODO check if RET or better RST8 with -1
0171   40B7 AF              XOR A		; sonst zurueck nach BASIC
0172   40B8 CF          	RST 08h
0173   40B9 FF          	db 0FFh
0174   40BA             	
0175   40BA             
0176   40BA             GENER_START: ; Interpreting the string independent of its origin, on ret A=0 for okay, BC retval to basic
0177   40BA 7E          	LD A,(HL)   ; HL=start, BC=length
0178   40BB 23              INC  HL
0179   40BC 0B              DEC  BC
0180   40BD             AA00:
0181   40BD 11 E0 40        LD   DE,GENER_END
0182   40C0 D5              PUSH DE     ; ret adddess
0183   40C1             ;	CP c_I		; Info
0184   40C1             ;	JP Z,INFO1
0185   40C1 FE 38       	CP c_S		; Save
0186   40C3             AA41:
0187   40C3 CA A8 42    	JP Z,SAVE1
0188   40C6 FE 31       	CP c_L		; Load
0189   40C8             AA42:
0190   40C8 CA D9 41    	JP Z,LOAD1
0191   40CB             ;	CP 29h		; ist es ein D;
0192   40CB             ;	JP Z,DIR1
0193   40CB             ;	CP 3Bh		; ist es ein V (UFM)
0194   40CB             ;	JP Z,DIRV1
0195   40CB             ;	CP 30h		; ist es ein K (UFM)
0196   40CB             ;	JP Z,DIRK1
0197   40CB             ;	CP 37h		; ist es ein R
0198   40CB             ;	JP Z,RENAM1
0199   40CB             ;	CP 2Ah		; ist es ein E
0200   40CB             ;	JP Z,ERAS1
0201   40CB FE 2E       	CP c_I		;  I
0202   40CD             AA02:
0203   40CD CA E8 40    	JP Z,INST_RELOC
0204   40D0 FE 39       	CP c_T		; Test, return 0...1023 dependng on number of correct bytes
0205   40D2             AA43:
0206   40D2 CA 7C 42    	JP Z,TESTPATTERN
0207   40D5 FE 2D       	CP c_H		; Help
0208   40D7             AA03:
0209   40D7 CA C6 43    	JP Z,HLP
0210   40DA FE 0F       	CP 0Fh		; ist es ein ?
0211   40DC             AA04:
0212   40DC CA C6 43    	JP Z,HLP
0213   40DF C9              ret 
0214   40E0             
0215   40E0             GENER_END:
0216   40E0 F5              PUSH AF ; holds our error status
0217   40E1 C5              PUSH BC ; ret value...
0218   40E2 CD 07 02    	CALL SHOW
0219   40E5 C1              POP  BC
0220   40E6 F1              POP  AF
0221   40E7 C9          	RET
0222   40E8             	
0223   40E8             INST_RELOC:
0224   40E8                 ; address with new memory location follows. Cpoies the driver and corrects the absolute adresses accordingly
0225   40E8             AA09:
0226   40E8 CD 3D 42        CALL PARS_DEC_NUM   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0227   40EB 3E 01           LD   A,1
0228   40ED C0              RET  NZ
0229   40EE D5              PUSH DE
0230   40EF CD E7 02    	CALL FAST	; go to fast mode so we can use index regs
0231   40F2 D1              POP  DE
0232   40F3 DD E5           PUSH IX     ; save IX till end
0233   40F5 D5              PUSH DE
0234   40F6 DD E1           POP  IX     ; new start addr in IX, will need it quite often
0235   40F8                 ; copy RAW driver
0236   40F8             AA06:
0237   40F8 21 82 40        LD HL,DRIVER_START
0238   40FB 01 E1 04        LD BC,DRIVER_END-DRIVER_START
0239   40FE ED B0           LDIR
0240   4100                 ; correct abs addr occurrences, all in this table:
0241   4100             AA07:
0242   4100 21 47 41        LD HL, RELOC_TABLE
0243   4103             RLCLOOP:
0244   4103 5E              LD   E,(HL)
0245   4104 23              INC  HL
0246   4105 56              LD   D,(HL)
0247   4106 23              INC  HL
0248   4107 7A              LD   A,D
0249   4108 B3              OR  E
0250   4109 28 1C           JR   Z, ENDRLCCP    ; null end marker
0251   410B E5              PUSH HL ; next RELOC_TABLE pos
0252   410C                 ; DE is position of the addr tag relative to start
0253   410C DD E5           PUSH IX
0254   410E E1              POP  HL
0255   410F 19              ADD  HL,DE
0256   4110                 ; HL is the absolute label pos to modify
0257   4110 E5              PUSH HL ; need it later to write
0258   4111 5E              LD   E,(HL) 
0259   4112 23              INC  HL
0260   4113 56              LD   D,(HL)
0261   4114             AA05:
0262   4114 21 82 40        LD   HL, DRIVER_START
0263   4117 EB              EX   DE,HL
0264   4118 A7          	AND A		; clear carry
0265   4119 ED 52       	SBC HL,DE	; actual address minus old offset
0266   411B             
0267   411B                 ; HL is relative addr
0268   411B DD E5           PUSH IX
0269   411D D1              POP  DE
0270   411E 19              ADD  HL,DE  ; add new offset
0271   411F EB              EX   DE,HL
0272   4120                 ; DE is new abs addr
0273   4120 E1              POP  HL
0274   4121 73              LD   (HL),E
0275   4122 23              INC  HL
0276   4123 72              LD   (HL),D
0277   4124 E1              POP HL ; restore RELOC_TABLE pos
0278   4125 18 DC           JR RLCLOOP
0279   4127             ENDRLCCP:
0280   4127 DD E1           POP  IX
0281   4129 AF              XOR  A
0282   412A 01 E1 04        LD   BC,DRIVER_END-DRIVER_START
0283   412D C9              RET
0284   412E              
0285   412E             
0286   412E             PRINTHEX:
0287   412E F5          	PUSH AF
0288   412F E5          	PUSH HL
0289   4130 C5          	PUSH BC
0290   4131 4F          	LD C,A		; SAVE
0291   4132 CB 3F       	SRL A
0292   4134 CB 3F       	SRL A
0293   4136 CB 3F       	SRL A
0294   4138 CB 3F       	SRL A
0295   413A C6 1C       	ADD A,1CH	; Offset to '0'
0296   413C D7          	RST 10H
0297   413D 79          	LD A,C
0298   413E E6 0F       	AND	0FH		; MASK
0299   4140 C6 1C       	ADD A,1CH	; Offset to '0'
0300   4142 D7          	RST 10H
0301   4143 C1          	POP BC
0302   4144 E1          	POP HL
0303   4145 F1          	POP AF
0304   4146 C9          	RET
0305   4147             
0306   4147             
0307   4147             RELOC_TABLE:
0308   4147              ;   dw 0
0309   4147 3C 00           dw AA00+1-DRIVER_START
0310   4149 21 00           dw AA01+1-DRIVER_START
0311   414B 4C 00           dw AA02+1-DRIVER_START
0312   414D 56 00           dw AA03+1-DRIVER_START
0313   414F 5B 00           dw AA04+1-DRIVER_START
0314   4151 93 00           dw AA05+1-DRIVER_START
0315   4153 77 00           dw AA06+1-DRIVER_START
0316   4155 7F 00           dw AA07+1-DRIVER_START
0317   4157 45 03           dw AA08+1-DRIVER_START
0318   4159 67 00           dw AA09+1-DRIVER_START
0319   415B             
0320   415B 5A 01           dw AA10+1-DRIVER_START
0321   415D 67 01           dw AA11+1-DRIVER_START
0322   415F 6A 01           dw AA12+1-DRIVER_START
0323   4161 76 01           dw AA13+1-DRIVER_START
0324   4163 7F 01           dw AA14+1-DRIVER_START
0325   4165 8B 01           dw AA15+1-DRIVER_START
0326   4167 95 01           dw AA16+1-DRIVER_START
0327   4169 B2 01           dw AA17+1-DRIVER_START
0328   416B FD 01           dw AA18+1-DRIVER_START
0329   416D 08 02           dw AA19+1-DRIVER_START
0330   416F             
0331   416F 11 02           dw AA20+1-DRIVER_START
0332   4171 29 02           dw AA21+1-DRIVER_START
0333   4173 33 02           dw AA22+1-DRIVER_START
0334   4175 48 02           dw AA23+1-DRIVER_START
0335   4177 52 02           dw AA24+1-DRIVER_START
0336   4179 60 02           dw AA25+1-DRIVER_START
0337   417B 6E 02           dw AA26+1-DRIVER_START
0338   417D 71 02           dw AA27+1-DRIVER_START
0339   417F 7D 02           dw AA28+1-DRIVER_START
0340   4181 85 02           dw AA29+1-DRIVER_START
0341   4183             
0342   4183 B2 03           dw AA30+1-DRIVER_START
0343   4185 BC 03           dw AA31+1-DRIVER_START
0344   4187 EE 03           dw AA32+1-DRIVER_START
0345   4189 F1 03           dw AA33+1-DRIVER_START
0346   418B FB 03           dw AA34+1-DRIVER_START
0347   418D 49 04           dw AA35+1-DRIVER_START
0348   418F 55 04           dw AA36+1-DRIVER_START
0349   4191 61 04           dw AA37+1-DRIVER_START
0350   4193 6D 04           dw AA38+1-DRIVER_START
0351   4195 79 04           dw AA39+1-DRIVER_START
0352   4197             
0353   4197 85 04           dw AA40+1-DRIVER_START
0354   4199 42 00           dw AA41+1-DRIVER_START
0355   419B 47 00           dw AA42+1-DRIVER_START
0356   419D 51 00           dw AA43+1-DRIVER_START
0357   419F 1A 00           dw AA44+1-DRIVER_START
0358   41A1 01 00           dw AA45+1-DRIVER_START
0359   41A3 48 03           dw AA46+1-DRIVER_START
0360   41A5 4B 03           dw AA47+1-DRIVER_START
0361   41A7 4E 03           dw AA48+1-DRIVER_START
0362   41A9 51 03           dw AA49+1-DRIVER_START
0363   41AB             
0364   41AB 54 03           dw AA50+1-DRIVER_START
0365   41AD 5A 03           dw AA51+1-DRIVER_START
0366   41AF             
0367   41AF 00 00           dw 0    ; final
0368   41B1             
0369   41B1             
0370   41B1             
0371   41B1             CHECKCOMMA:  ; Z is set when comma seperator found in string, NZ if not, uses A
0372   41B1                 ; BC =0?
0373   41B1 AF              XOR  A
0374   41B2 B9              CP   C
0375   41B3 20 02           JR   NZ,CHKK_CONT
0376   41B5 3C              INC  A ; clear the Z flag
0377   41B6 C9              RET     ; no match till end
0378   41B7             CHKK_CONT:
0379   41B7 7E              LD   A, (HL)
0380   41B8 FE 1A           CP   26     ; comma
0381   41BA C8              RET  z
0382   41BB FE 19           CP   25     ; also check for semicolon
0383   41BD C8              RET  z
0384   41BE 23              INC  HL
0385   41BF 0B              DEC  BC
0386   41C0 18 EF           JR CHECKCOMMA
0387   41C2             
0388   41C2             
0389   41C2             SKIPEMPTY:  ; Z is set when comma seperator found in string, NZ if not, uses A
0390   41C2                 ; BC =0?
0391   41C2 AF              XOR  A
0392   41C3 B9              CP   C
0393   41C4 20 05           JR   NZ,CHKE_CONT
0394   41C6 B8              CP   B
0395   41C7 20 02           JR   NZ,CHKE_CONT
0396   41C9 3C              INC  A ; clear the Z flag
0397   41CA C9              RET     ; no match till end
0398   41CB             CHKE_CONT:
0399   41CB BE              CP   (HL)
0400   41CC C0              RET  NZ ; not empty,leave
0401   41CD 23              INC  HL
0402   41CE 0B              DEC  BC
0403   41CF 18 F1           JR SKIPEMPTY
0404   41D1             
0405   41D1             PRINTA:
0406   41D1 E5              PUSH HL
0407   41D2 D5              PUSH DE
0408   41D3 C5              PUSH BC
0409   41D4 D7              RST 10H
0410   41D5 C1              POP  BC
0411   41D6 D1              POP  DE
0412   41D7 E1              POP  HL
0413   41D8 C9              RET
0414   41D9                 
0415   41D9             
0416   41D9             LOAD1:
0417   41D9             	; HL points to arg string, BC number of chars
0418   41D9 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0419   41DA C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0420   41DB                 ; Check if we have contact
0421   41DB             AA10:    
0422   41DB CD 33 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0423   41DE A7              AND A
0424   41DF                 ; Send LOAD request
0425   41DF C1              POP  BC
0426   41E0 E1              POP  HL ; recover name pointer/length
0427   41E1 28 4B           JR   Z, LD_ERR ; NO CONTACT after TRY_HANDSHAKE
0428   41E3 E5              PUSH HL  ; and again store for binload
0429   41E4 C5              PUSH BC  ; 
0430   41E5             
0431   41E5 41              ld   B,C ; length, assume <256
0432   41E6 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0433   41E8             AA11:
0434   41E8 CD B0 44        CALL SEND_PACKET
0435   41EB             
0436   41EB                 ; now retrieve key, must be 123
0437   41EB             AA12:
0438   41EB CD 82 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0439   41EE FE 7B           CP  123
0440   41F0 20 3A           JR NZ,LD_ERR2
0441   41F2 06 04           LD   B,4
0442   41F4 7E              LD  A,(HL)  ; dummy for timing
0443   41F5              
0444   41F5             LOADELY1:         ;    //47 delay between the header bytes
0445   41F5 10 FE           DJNZ LOADELY1
0446   41F7             
0447   41F7                 ; now retrieve length, 0 for error
0448   41F7             AA13:
0449   41F7 CD 82 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0450   41FA 6F              LD   L,A
0451   41FB 06 05           LD   B,5
0452   41FD             
0453   41FD             LOADELY2:         ;    //60 delay between the length bytes
0454   41FD 10 FE           DJNZ LOADELY2
0455   41FF             
0456   41FF 00              NOP
0457   4200             AA14:
0458   4200 CD 82 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0459   4203 67              LD   H,A
0460   4204 B5              OR   L
0461   4205 28 25           JR Z,LD_ERR2
0462   4207 EB              EX   DE,HL
0463   4208                 ; Here we have DE= len
0464   4208                 ; get addr
0465   4208 C1              POP  BC
0466   4209 E1              POP  HL ; recover name pointer/length
0467   420A D5              PUSH DE             ; length, will go to BC below
0468   420B D5              PUSH DE             ; length, again, for end result
0469   420C             
0470   420C             
0471   420C                 ;  test if saving binary or regular basic
0472   420C             AA15:
0473   420C CD B1 41        CALL CHECKCOMMA
0474   420F 28 20           JR   Z, BINLOAD
0475   4211             
0476   4211                 ; LOAD BASIC program if not BINLOAD, set addr
0477   4211 21 09 40    	LD HL,4009h		; 
0478   4214 1E 01           LD   E,1        ; mark as basic load
0479   4216             
0480   4216             LOADLOOP:
0481   4216                 ; timing  - 74 between calls seems to be more reliable than 70!
0482   4216             AA16:
0483   4216 CD 82 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0484   4219 77              LD   (HL),A
0485   421A 77              LD   (HL),A ; dummy for timing
0486   421B 23              INC  HL
0487   421C C1              POP  BC     ; get remaining length
0488   421D 0B              DEC  BC
0489   421E 79              LD   A,C
0490   421F B0              OR   B
0491   4220 28 03           JR Z, LD_END
0492   4222 C5              PUSH BC
0493   4223 18 F1           JR  LOADLOOP
0494   4225             LD_END:  
0495   4225 C1              POP  BC ; orig length
0496   4226 AF              XOR  A
0497   4227 BB              CP   E  ; 0 for binary
0498   4228 C8              RET   Z ; normal return for binload with length in BC
0499   4229                 ; end for BASIC loader
0500   4229 D1              POP  DE ; dummy, ret addr
0501   422A CF          	RST 08h ;
0502   422B FF          	db 0FFh
0503   422C             
0504   422C             
0505   422C             LD_ERR2:
0506   422C D1              POP  DE ; dummy
0507   422D D1              POP  DE ; dummy
0508   422E             LD_ERR:
0509   422E 3E 01           LD   A,1
0510   4230 C9              RET ; BC WILL be at maximum now
0511   4231             
0512   4231             
0513   4231             
0514   4231             BINLOAD: ; HL points to the comma in arg string, now parse addr, length
0515   4231 23              INC  HL
0516   4232 0D              DEC  C
0517   4233             AA17:
0518   4233 CD 3D 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0519   4236 20 F4           JR NZ, LD_ERR2   ; parse error
0520   4238                 ; addr in DE
0521   4238 EB              EX   DE,HL
0522   4239 1E 00           LD   E,0    ; mark as binary
0523   423B 18 D9           JR LOADLOOP
0524   423D             
0525   423D             
0526   423D             
0527   423D             ; parse a decimal number
0528   423D             PARS_DEC_NUM:   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0529   423D 11 00 00    	LD DE, 0
0530   4240 AF              XOR  A
0531   4241 B9              CP   C
0532   4242 28 35           JR Z,PARSFAIL
0533   4244             
0534   4244             PARS_LLOOP:     ; look for first number
0535   4244 7E          	LD A,(HL)
0536   4245 A7          	AND A
0537   4246 28 29       	JR Z, PARS_SKIPWS ; skip whitespace
0538   4248             PARS_LLP2:
0539   4248 D6 1C       	SUB 01ch	;"0"
0540   424A 38 2D       	JR C,PARSFAIL
0541   424C FE 0A       	CP 10
0542   424E 30 29       	JR NC,PARSFAIL
0543   4250             	; have a digit in A,
0544   4250 E5          	PUSH HL
0545   4251             	; DE times ten
0546   4251 62          	LD H,D      ; now in both HL and DE
0547   4252 6B          	LD L,E
0548   4253 29          	ADD HL,HL
0549   4254 29          	ADD HL,HL
0550   4255 29          	ADD HL,HL ; times 8 so far
0551   4256 19          	ADD HL,DE
0552   4257 19          	ADD HL,DE
0553   4258             	; Add new digit
0554   4258 16 00       	LD D,0
0555   425A 5F          	LD E,A
0556   425B 19          	ADD HL,DE
0557   425C EB          	EX DE,HL    ; new value of DE
0558   425D E1          	POP HL  ; pointer to argline back in HL
0559   425E 23          	INC HL
0560   425F 0D          	DEC C
0561   4260 28 15           JR Z,PARSDONE
0562   4262 7E          	LD A,(HL)   ; load next char to see if end
0563   4263 FE 1A           CP   26 ;  ','
0564   4265 28 10           JR Z,PARSDONE
0565   4267 FE 0E           CP   14 ;  ';'
0566   4269 28 0C           JR Z,PARSDONE
0567   426B FE 0B           CP   11 ;  '"'
0568   426D 28 08           JR Z,PARSDONE
0569   426F 18 D7       	JR PARS_LLP2 
0570   4271             PARS_SKIPWS:
0571   4271 23          	INC HL
0572   4272 0D          	DEC C
0573   4273 28 04           JR Z,PARSFAIL
0574   4275 18 CD       	JR PARS_LLOOP 
0575   4277             
0576   4277             PARSDONE:
0577   4277 AF              XOR  A
0578   4278 C9          	RET
0579   4279             PARSFAIL:
0580   4279 AF              XOR  A
0581   427A 3C              INC  A
0582   427B C9          	RET
0583   427C             
0584   427C             
0585   427C             TESTPATTERN:
0586   427C             	; HL points to arg string, BC number of chars
0587   427C E5              PUSH HL  ; orig pos of args (w/o prefix T)
0588   427D C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0589   427E                 ; Check if we have contact
0590   427E             AA18:    
0591   427E CD 33 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0592   4281 A7              AND A
0593   4282                 ; Send LOAD request
0594   4282 C1              POP  BC
0595   4283 E1              POP  HL ; recover name pointer/length
0596   4284 28 1C           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0597   4286             
0598   4286 41              ld   B,C ; length, assume <256
0599   4287 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0600   4289             AA19:
0601   4289 CD B0 44        CALL SEND_PACKET
0602   428C             
0603   428C                 ; now retrieve 1024 bytes and see how many are correct
0604   428C                 ; gap between byte calls should be 77+12+7 - 17-10 = 69 clocks
0605   428C 01 00 00        LD   BC,0
0606   428F             TESTBLOOP:
0607   428F C5              PUSH BC
0608   4290 00              NOP         ; timing adjust 66/70
0609   4291 00              NOP         ; timing adjust 70/74 - 74 seems to be more reliable than 70!
0610   4292             AA20:
0611   4292 CD 82 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0612   4295 C1              POP  BC
0613   4296 B9              CP   C  ; incomming data in A is 0,1,2,3,4...255,0,1... as byte
0614   4297 3E 00           LD   A,0 ; not affect flags, test never reports errors to better automatize
0615   4299 C0              RET  NZ ; report BC at point of first failure
0616   429A 03              INC  BC
0617   429B 3E 10           LD   A,16 ; 4kbyte testsize
0618   429D B8              CP   B
0619   429E 20 EF           JR   NZ, TESTBLOOP
0620   42A0 AF              XOR  A
0621   42A1 C9              RET ; BC WILL be at maximum now
0622   42A2             
0623   42A2             
0624   42A2             
0625   42A2             ERREXIT:
0626   42A2 3E 01           LD   A,1
0627   42A4 01 00 00        LD   BC,0
0628   42A7 C9              RET
0629   42A8             
0630   42A8             SAVE1:
0631   42A8             	; HL points to arg string, BC number of chars
0632   42A8 E5              PUSH HL  ; orig pos of args (w/o prefix S)
0633   42A9 C5              PUSH BC  ; orig lenght of args (w/o prefix S)
0634   42AA             
0635   42AA             
0636   42AA             ;    LD   A, c_S
0637   42AA             ;    CALL PRINTA
0638   42AA             
0639   42AA                 ; Check if we have contact
0640   42AA             AA21:   
0641   42AA CD 33 44        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0642   42AD                 ; Send SAVE request
0643   42AD C1              POP  BC
0644   42AE E1              POP  HL ; recover name pointer/length
0645   42AF                 ; evauate connect result
0646   42AF A7              AND A
0647   42B0 28 F0           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0648   42B2             
0649   42B2                 ; again store original argument string, will need it now and when sending name
0650   42B2 E5              PUSH HL
0651   42B3 C5              PUSH BC
0652   42B4             
0653   42B4                 ;  test if saving binary or regular basic
0654   42B4             AA22:
0655   42B4 CD B1 41        CALL CHECKCOMMA
0656   42B7 28 43           JR   Z, BINSAVE
0657   42B9             
0658   42B9                 ; SAVE BASIC program if not BINSAVE, pre-calc addr,size into HL and BC
0659   42B9 11 09 40    	LD DE,4009h		; Get length
0660   42BC 2A 14 40    	LD HL,(ELINE)	
0661   42BF A7          	AND A		; clear carry
0662   42C0 ED 52       	SBC HL,DE	; HL=length
0663   42C2 44          	LD B,H
0664   42C3 4D          	LD C,L
0665   42C4 EB          	EX DE,HL	; Now HL=Start, BC=length
0666   42C5             
0667   42C5             SAVE_CONT: ;continue common path of BIN and BASIC save
0668   42C5 D9              EXX     ; store payload addr and length for now
0669   42C6 EB          	EX DE,HL	; HL' must be restored, save in DE'
0670   42C7 C1              POP  BC
0671   42C8 E1              POP  HL ; recover name pointer/length
0672   42C9             AA23:
0673   42C9 CD C2 41        CALL SKIPEMPTY 
0674   42CC AF              XOR  A
0675   42CD B9              CP   C
0676   42CE 28 40           JR   Z, ERREXIT3 ; NO NAME
0677   42D0 41              ld   B,C ; length, assume <256
0678   42D1 0E 5B           ld   C,91 ; packet ID ZX_QSAVE_TAG_SAVEPFILE
0679   42D3             AA24:
0680   42D3 CD B0 44        CALL SEND_PACKET
0681   42D6 EB          	EX DE,HL	; HL' must be restored, was saved in DE'
0682   42D7 D9              EXX ; Recover, now HL=Start, BC=length
0683   42D8             	
0684   42D8             SVSENDFUL:
0685   42D8 AF              XOR  A
0686   42D9 B8              CP   B
0687   42DA 28 0C           JR   Z, SVSENDLAST
0688   42DC                 ; send full packets
0689   42DC C5              PUSH BC
0690   42DD 06 00           LD   B,0    ; 256 bytes
0691   42DF 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0692   42E1             AA25:
0693   42E1 CD B0 44        CALL SEND_PACKET
0694   42E4 C1              POP  BC
0695   42E5 05              DEC  B
0696   42E6 18 F0           JR   SVSENDFUL
0697   42E8             
0698   42E8             SVSENDLAST:
0699   42E8 AF              XOR  A
0700   42E9 B9              CP   C
0701   42EA 28 06           JR   Z, SVSENDEND
0702   42EC 41              LD   B,C ; length
0703   42ED 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0704   42EF             AA26:
0705   42EF CD B0 44        CALL SEND_PACKET
0706   42F2             
0707   42F2             SVSENDEND:
0708   42F2             AA27:
0709   42F2 CD 68 44        CALL QS_FINAL_ACK   ; Z set for success
0710   42F5 20 AB           JR   NZ, ERREXIT
0711   42F7 AF              XOR  A
0712   42F8 01 01 00        LD   BC, 1
0713   42FB C9          	RET
0714   42FC             
0715   42FC             
0716   42FC             BINSAVE: ; HL points to the comma in arg string, now parse addr, length
0717   42FC 23              INC  HL
0718   42FD 0D              DEC  C
0719   42FE             AA28:
0720   42FE CD 3D 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0721   4301 20 13           JR NZ, BSERREXIT   ; parse error
0722   4303 D5              PUSH DE ; store addr, from now on have to use BSERREXIT2 to stack-unwind here
0723   4304 23              INC  HL
0724   4305 0D              DEC  C
0725   4306             AA29:
0726   4306 CD 3D 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0727   4309 20 0A           JR NZ, BSERREXIT2   ; parse error
0728   430B                 ; length in DE
0729   430B                 ; Now put HL=Start, BC=length
0730   430B 42              LD   B,D
0731   430C 4B              LD   C,E
0732   430D E1              POP  HL
0733   430E 18 B5           JR SAVE_CONT
0734   4310             
0735   4310             ERREXIT3:
0736   4310 EB          	EX DE,HL	; HL' must be restored, saved in DE'
0737   4311 D9              EXX ; Recover
0738   4312 3E 01           LD   A,1
0739   4314 C9          	RET
0740   4315             
0741   4315             BSERREXIT2:
0742   4315 D1              POP  DE
0743   4316             BSERREXIT:
0744   4316 C1              POP  BC
0745   4317 E1              POP  HL ; recover name pointer/length
0746   4318 3E 01           LD   A,1
0747   431A C9          	RET
0748   431B             
0749   431B             
0750   431B             HLPTXT1:
0751   431B 3F 3D 00 3C 	db c_Z,c_X,0,c_W,c_E,c_S,c_P,c_I,0,c_D,c_R,c_I,c_V,c_E,c_R,c_NEWLINE
0751   431F 2A 38 35 2E 
0751   4323 00 29 37 2E 
0751   4327 3B 2A 37 76 
0752   432B 76 76           db c_NEWLINE,c_NEWLINE
0753   432D 35 37 2E 33 	db c_P,c_R,c_I,c_N,c_T, 0 , c_U, c_S, c_R, 0 
0753   4331 39 00 3A 38 
0753   4335 37 00 
0754   4337 FF          	db $ff
0755   4338             
0756   4338             ;	db "INFO  ",22h,"I",22h,0dh
0757   4338             ;	db "DIR   ",22h,"D",22h,0dh
0758   4338             ;	db "ERASE ",22h,"ENAME.P",22h,0dh
0759   4338             ;	db "MKDIR ",22h,"DMVERZ",22h,0dh
0760   4338             ;	db "RMDIR ",22h,"DEVERZ",22h,0dh
0761   4338             ;	db "CHDIR ",22h,"DCVERZ",22h,0dh
0762   4338             HLPTXT2:
0763   4338 1A 0B 13 28 	db 26, 11, 19, c_C,c_M,c_D, 18,  11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0763   433C 32 29 12 0B 
0763   4340 76 
0764   4341 76 76           db c_NEWLINE,c_NEWLINE
0765   4343 31 34 26 29 	db c_L,c_O,c_A,c_D, 0 , 0 , 0, 11, c_L, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0765   4347 00 00 00 0B 
0765   434B 31 33 26 32 
0765   434F 2A 0B 76 
0766   4352 38 26 3B 2A 	db c_S,c_A,c_V,c_E, 0 , 0 , 0, 11, c_S, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0766   4356 00 00 00 0B 
0766   435A 38 33 26 32 
0766   435E 2A 0B 76 
0767   4361 27 31 34 26 	db c_B,c_L,c_O,c_A,c_D, 0 , 0, 11, c_L, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 11,c_NEWLINE   ; "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0767   4365 29 00 00 0B 
0767   4369 31 33 26 32 
0767   436D 2A 1A 26 29 
0767   4371 29 37 0B 76 
0768   4375 27 38 26 3B 	db c_B,c_S,c_A,c_V,c_E, 0 , 0, 11, c_S, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 26, c_L, c_E, c_N,  11,c_NEWLINE   ; "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0768   4379 2A 00 00 0B 
0768   437D 38 33 26 32 
0768   4381 2A 1A 26 29 
0768   4385 29 37 1A 31 
0768   4389 2A 33 0B 76 
0769   438D 2D 2A 31 35 	db c_H,c_E,c_L,c_P, 0 , 0 , 0, 11, c_H, 11,c_NEWLINE   ;  c_H,   "HELP  ",22h,"H",22h,0dh
0769   4391 00 00 00 0B 
0769   4395 2D 0B 76 
0770   4398             ;	db "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0771   4398             ;	db "RENAME",22h,"ROLDNAME NEWNAME",22h,0dh
0772   4398 76              db c_NEWLINE
0773   4399 2E 33 38 39 	db c_I,c_N,c_S,c_T,c_A,c_L,c_L, 0 , c_D,c_R,c_V, 0 ,c_T,c_O, 0, c_R,c_A,c_M,  0, 11, c_I, 0, c_A, c_D, c_D, c_R,  11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0773   439D 26 31 31 00 
0773   43A1 29 37 3B 00 
0773   43A5 39 34 00 37 
0773   43A9 26 32 00 0B 
0773   43AD 2E 00 26 29 
0773   43B1 29 37 0B 76 
0774   43B5             ;	db c_T,c_E,c_S,c_T, 0 , 0 , 0, 11, c_T, c_L, c_T, c_T, c_T, c_0+2, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0775   43B5             ;	db "FOR SIGGI'S UFM :V/R/K",0dh
0776   43B5 76              db c_NEWLINE
0777   43B6 76              db c_NEWLINE
0778   43B7 37 2A 3B 00     db c_R, c_E, c_V, 0, c_A, c_0+1,0,0,0, c_S, c_I, c_Z, c_E, 0
0778   43BB 26 1D 00 00 
0778   43BF 00 38 2E 3F 
0778   43C3 2A 00 
0779   43C5 FF          	db $ff
0780   43C6             
0781   43C6             
0782   43C6             ; === Subroutine print help text ====
0783   43C6             AA08:
0784   43C6             HLP:
0785   43C6 21 1B 43    	LD HL,HLPTXT1
0786   43C9             AA46:
0787   43C9 CD E3 43        CALL PRINTTEXT
0788   43CC             AA47:
0789   43CC 21 82 40    	LD HL,DRIVER_START
0790   43CF             AA48:
0791   43CF CD EB 43        CALL PRINTBASE10
0792   43D2             AA49:
0793   43D2 21 38 43    	LD HL,HLPTXT2
0794   43D5             AA50:
0795   43D5 CD E3 43        CALL PRINTTEXT
0796   43D8 21 E1 04        LD HL,DRIVER_END-DRIVER_START
0797   43DB             AA51:
0798   43DB CD EB 43        CALL PRINTBASE10
0799   43DE 01 2A 00        LD   BC,42
0800   43E1 AF              XOR  A
0801   43E2 C9              RET
0802   43E3             
0803   43E3             ; Text in HL, FF marks end
0804   43E3             PRINTTEXT:
0805   43E3 7E          HLP1:	LD A,(HL)
0806   43E4 FE FF       	CP $FF
0807   43E6 C8          	RET Z
0808   43E7 D7              RST 10H
0809   43E8 23          	INC HL
0810   43E9 18 F8       	JR HLP1
0811   43EB             
0812   43EB             
0813   43EB             ; *
0814   43EB             ; * PRINT HL DECIMAL
0815   43EB             ; *
0816   43EB             PRINTBASE10:
0817   43EB E5          	PUSH HL
0818   43EC C5          	PUSH BC
0819   43ED D5          	PUSH DE
0820   43EE AF              XOR A
0821   43EF F5          	PUSH AF
0822   43F0             _PRTLP:
0823   43F0 CD 05 44    	CALL _DIV10
0824   43F3 C6 1C       	ADD A,1CH
0825   43F5 F5          	PUSH AF
0826   43F6 7C          	LD A,H
0827   43F7 B5          	OR L
0828   43F8 20 F6       	JR NZ,_PRTLP
0829   43FA             _PRTL1:
0830   43FA F1          	POP AF
0831   43FB B7          	OR A
0832   43FC 20 04       	JR NZ,_PRT2
0833   43FE D1          	POP DE
0834   43FF C1          	POP BC
0835   4400 E1          	POP HL
0836   4401 C9          	RET
0837   4402             _PRT2
0838   4402 D7          	RST 10H
0839   4403 18 F5       	JR _PRTL1
0840   4405             ; * HL=HL/10 A=REMAINDE
0841   4405             _DIV10:
0842   4405 06 10       	LD B,10h
0843   4407 AF          	XOR A
0844   4408             _DIVLP:
0845   4408 CB 25       	SLA L
0846   440A CB 14       	RL H
0847   440C 17          	RLA
0848   440D FE 0A       	CP 0Ah
0849   440F 38 04       	JR C,_SK
0850   4411 CB C5       	SET 0,L
0851   4413 D6 0A       	SUB 0Ah
0852   4415             _SK:
0853   4415 10 F1       	DJNZ _DIVLP
0854   4417 C9          	RET
0855   4418             
0856   4418             
0857   4418             GO_QSAVE_MODE:
0858   4418 CD E7 02    	CALL FAST	; go to fast mode
0859   441B DB FE           IN      A,($FE)         ; signal to 0 pause    
0860   441D 06 C8           LD B,200  ; 200=200ms Pause
0861   441F C5          W1: push BC
0862   4420 06 00           ld b,0
0863   4422             W2:
0864   4422 10 FE           djnz W2     ; 1 millisec (256*4)
0865   4424 C1              pop BC
0866   4425 10 F8           djnz W1
0867   4427 1E 4B           LD E, 75    ; ID for ZX_SAVE_TAG_QSAVE_START
0868   4429 CD 1F 03        CALL $031F  ; SAVE byte in E
0869   442C D3 FF           OUT     ($FF),A         ; ; signal to 1 / syncoff, send hsyncs
0870   442E 06 00           ld b,0
0871   4430             W4:
0872   4430 10 FE           djnz W4     ; 1 millisec (256*4) to go to QSAVE mode
0873   4432 C9              RET
0874   4433             
0875   4433             TRY_HANDSHAKE:  ; See if WESPI responds, return 1 if so, 0 for timeout
0876   4433             AA30:
0877   4433 CD 18 44        CALL GO_QSAVE_MODE
0878   4436 21 04 40        ld   hl, 16388 ; RAMTOP
0879   4439 06 02           ld   B,2
0880   443B 0E 5A           ld   C,90 ; packet ID ZX_QSAVE_TAG_HANDSHAKE
0881   443D             AA31:
0882   443D CD B0 44        CALL SEND_PACKET
0883   4440 06 B5           ld   b,181  ; timeout, 500ms (inner loop 3.15ms)
0884   4442             HS_LOOP1:
0885   4442 C5              PUSH BC
0886   4443 06 00           LD   B,0
0887   4445             HS_LOOP2:                  ; 35 cycles=10.7us, inner Loop 2.75 millisec
0888   4445 DB FE           in a,($FE)  ; 11
0889   4447 17              rla         ; 4
0890   4448 38 0E           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0891   444A 10 F9           DJNZ HS_LOOP2 ;13
0892   444C                 ; re-check here to not have a blind spot for outer loop
0893   444C DB FE           in a,($FE)  ; 11
0894   444E 17              rla         ; 4
0895   444F 38 07           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0896   4451 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff in between to not let levels drift (not good for follow-up cmds?)
0897   4453 C1              POP  BC
0898   4454 10 EC           DJNZ HS_LOOP1
0899   4456                 ; no signal found
0900   4456 AF              XOR  A
0901   4457 C9              RET
0902   4458             
0903   4458             HS_FOUND
0904   4458 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0905   445A                 ; let the output recover with active signal after being low from input. takes about 1ms as seen in oscilloscope
0906   445A 06 00           LD   B,0
0907   445C             HS_FINALDELAY: ; 3ms here before next cmd
0908   445C 7E              LD   A,(HL)
0909   445D 7E              LD   A,(HL)
0910   445E 7E              LD   A,(HL)    
0911   445F 7E              LD   A,(HL)    
0912   4460 10 FA           DJNZ HS_FINALDELAY
0913   4462 C1              POP  BC
0914   4463 3E 01           LD   A,1
0915   4465 A7              AND  A
0916   4466 C9              RET
0917   4467             
0918   4467             QS_FINAL_SZ:
0919   4467 00              db 0 ; size of return packet to request, use smallest possible
0920   4468             
0921   4468             QS_FINAL_ACK:  ; Get info is operation was sussessful (Z) or failed (NZ), USES BC DE HL, A
0922   4468 21 67 44        ld   hl, QS_FINAL_SZ ; Requested length
0923   446B 06 01           ld   B,1
0924   446D 0E 63           LD   C,99 ; packet ID ZX_QSAVE_TAG_END_RQ
0925   446F             AA32:
0926   446F CD B0 44        CALL SEND_PACKET
0927   4472             
0928   4472                 ; await reply, first byte is tag, then result
0929   4472             AA33:
0930   4472 CD 82 44        CALL QLD_GETBYTE
0931   4475 FE 2A           CP   42 ; tag
0932   4477 C0              RET  NZ
0933   4478 06 08           ld B,8  ; 
0934   447A             QSFDLY:
0935   447A 10 0F           djnz lgapdly     ; 13*n-5 = 47 for 4
0936   447C             AA34:
0937   447C CD 82 44        CALL QLD_GETBYTE
0938   447F FE 01           CP   1 ; result
0939   4481 C9              RET    ; Z on match
0940   4482             
0941   4482             
0942   4482             
0943   4482             ; gab between byte calls should be 77+12+7 - 17-10 = 69 clocks
0944   4482             
0945   4482             QLD_GETBYTE:    ; uses BC D, result in A
0946   4482 0E FE           ld c,$fe   ; 7
0947   4484 06 08           ld b,8  ; 7    for gap between start and bits
0948   4486             
0949   4486             lwt_stdly:                  ; 25 cycles=7.7us
0950   4486 DB FE           in a,($FE)  ; 11
0951   4488 17              rla         ; 4
0952   4489 30 FB           jr nc,lwt_stdly ; 12 / 7  (D7=0 is low level, wait for high)
0953   448B                 ; trigger is seen 4us too late in average, so wait 48-4 - 4 us now: 130 cy in-in
0954   448B             lgapdly:
0955   448B 10 FE           djnz lgapdly     ; 13*n-5 = 99 for 8
0956   448D 06 08           ld b,8  ; 7
0957   448F             lbloop:                 ;  need 104 for 32us
0958   448F ED 50           in d,(c)    ; 12
0959   4491 CB 12           rl d        ; 8
0960   4493 17              rla         ; 4 (rl a is 8)
0961   4494 16 04           ld d,4      ; 7
0962   4496             lbdly:
0963   4496 15              dec d          ; 4          b*16-5 = 59
0964   4497 20 FD           jr nz,lbdly     ; 12 / 7
0965   4499 10 F4           djnz lbloop     ; 13 / 8
0966   449B C9              RET     
0967   449C                 
0968   449C                 ;ORIGINAL:
0969   449C                 ;ld (hl),a   ; 7
0970   449C             	;CALL UPDATE  ; will use DE, inc HL    77 clks
0971   449C                 ;jr lwt_start     ; 12
0972   449C             
0973   449C             
0974   449C             
0975   449C             
0976   449C             ;*
0977   449C             ;* Evaluate string  start of the string is in HL and the length in BC
0978   449C             ;*
0979   449C E7          NAME:	RST 20h
0980   449D CD 55 0F    	CALL 0F55h ; evaluate
0981   44A0 3A 01 40    	LD A,(4001h)
0982   44A3 87          	ADD A,A
0983   44A4 FA 9A 0D    	JP M,0D9Ah  ; error
0984   44A7 E1          	POP HL
0985   44A8 D0          	RET NC
0986   44A9 E5          	PUSH HL
0987   44AA CD F8 13    	CALL 13F8h ; get indexvar fom calc stack STK-FETCH
0988   44AD                 ; For strings, the start of the string is in DE and the length in BC
0989   44AD 62          	LD H,D
0990   44AE 6B          	LD L,E
0991   44AF C9          	RET
0992   44B0             
0993   44B0             
0994   44B0             SEND_PACKET: ; HL points to data, C holds type, B lenght (0=256bytes), HL will point behind sent data afterwards
0995   44B0 F5              PUSH AF
0996   44B1 C5              PUSH BC ; BC needed twice, for header, and recovered at end
0997   44B2 C5              PUSH BC
0998   44B3             
0999   44B3 06 E1           LD B,225    ;   TODO 125 should be enough
1000   44B5             SPWT:
1001   44B5 10 FE           djnz SPWT     ; 500 microsec  (125*4)  ; let the video lines sync again, require 5 lines (320), some margin added
1002   44B7             
1003   44B7                 ; we want all our pulses in sync with the HSYNC pulses to not interfere   
1004   44B7 AF              XOR A       ; make sure A' not at sync or display position to
1005   44B8 08              EX AF,AF'   ; just cause short INT on MNI here:
1006   44B9                             
1007   44B9 D3 FE           OUT ($FE),A  ; ENABLE NMI
1008   44BB 76              HALT
1009   44BC D3 FD           OUT ($FD),A  ; Disable NMI   from here, start first bit in 54us =174cy
1010   44BE DB FE           IN      A,($FE)         ; signal to 0 /on - syncout
1011   44C0 7E              LD   A,(HL)     ; 7 dummy 
1012   44C1 00              NOP             ; 4
1013   44C2 06 07           LD   B,7
1014   44C4 00              NOP             ; timing adjust to have bits symmetrical in (black-shouldered) line
1015   44C5 D3 FF           OUT     ($FF),A ;11        ; signal to 1 / syncoff
1016   44C7             waitnline:
1017   44C7 10 FE           DJNZ waitnline          ; delay for next line 13 per loop ..
1018   44C9 C1              POP  BC            ;10
1019   44CA             
1020   44CA             
1021   44CA                 ; Send packettype in C
1022   44CA             AA35:
1023   44CA CD 10 45        CALL SENDNIBBLE ;151, so we need 56 cycles between nibbles to get to 207 for one hsync line
1024   44CD             
1025   44CD 23              INC  HL         ; 6  ; DUMMY matching later dec
1026   44CE 7E              LD   A,(HL)     ; 7 
1027   44CF D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1028   44D1 7E              LD   A,(HL)     ; 7 
1029   44D2 7E              LD   A,(HL)     ; 7 
1030   44D3 7E              LD   A,(HL)     ; 7 
1031   44D4 7E              LD   A,(HL)     ; 7 
1032   44D5 00              NOP
1033   44D6             AA36:
1034   44D6 CD 10 45        CALL SENDNIBBLE ;151
1035   44D9             
1036   44D9 2B              DEC  HL 
1037   44DA 7E              LD   A,(HL)     ; 7 
1038   44DB D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
1039   44DD 7E              LD   A,(HL)     ; 7 
1040   44DE 7E              LD   A,(HL)     ; 7 
1041   44DF 7E              LD   A,(HL)     ; 7 
1042   44E0 7E              LD   A,(HL)     ; 7 
1043   44E1 48              LD C,B             ;4
1044   44E2             
1045   44E2                 ; Send length in B
1046   44E2             AA37:
1047   44E2 CD 10 45        CALL SENDNIBBLE ;151
1048   44E5             
1049   44E5 23              INC  HL         ; 6  ; DUMMY matching later dec
1050   44E6 7E              LD   A,(HL)     ; 7 
1051   44E7 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1052   44E9 7E              LD   A,(HL)     ; 7 
1053   44EA 7E              LD   A,(HL)     ; 7 
1054   44EB 7E              LD   A,(HL)     ; 7 
1055   44EC 7E              LD   A,(HL)     ; 7 
1056   44ED 00              NOP             ; 4
1057   44EE             AA38:
1058   44EE CD 10 45        call SENDNIBBLE ;151
1059   44F1             
1060   44F1 2B              DEC  HL 
1061   44F2 7E              LD   A,(HL)     ; 7 
1062   44F3             byteloop:
1063   44F3 D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
1064   44F5 7E              LD   A,(HL)     ; 7 
1065   44F6 7E              LD   A,(HL)     ; 7 
1066   44F7 7E              LD   A,(HL)     ; 7 
1067   44F8 4E              LD   C,(HL)     ; 7 
1068   44F9 00              NOP
1069   44FA             AA39:
1070   44FA CD 10 45        call SENDNIBBLE ;151
1071   44FD 23              INC  HL         ; 6
1072   44FE 7E              LD   A,(HL)     ; 7 
1073   44FF D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1074   4501 7E              LD   A,(HL)     ; 7 
1075   4502 7E              LD   A,(HL)     ; 7 
1076   4503 7E              LD   A,(HL)     ; 7 
1077   4504 7E              LD   A,(HL)     ; 7 
1078   4505 00              NOP
1079   4506                                 ; 56
1080   4506             AA40:    
1081   4506 CD 10 45        CALL SENDNIBBLE ;151
1082   4509 10 E8           DJNZ byteloop   ; 13
1083   450B D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1084   450D             
1085   450D C1              POP  BC
1086   450E F1              POP  AF
1087   450F C9              ret
1088   4510             
1089   4510             
1090   4510             SENDNIBBLE: ;31 per bit, 134 incl RET 151 incl call, nibble in C lower half
1091   4510                 ; Four bits to send
1092   4510                 ;# bit 1 start
1093   4510 CB 01           RLC C       ; 8
1094   4512 38 19           JR C, csendH1 ; 12/7
1095   4514 D8              ret c        ; 11/5 dummy for symmetric timing
1096   4515                 ;# bit 1 send 0
1097   4515 DB FE           IN      A,($FE)         ; signal to 0 /on
1098   4517             
1099   4517                 ;# bit 2 start
1100   4517 CB 01           RLC C       ; 8
1101   4519 38 2A           JR C, csendH2 ; 12/7
1102   451B D8              ret c        ; 11/5 dummy for symmetric timing
1103   451C                 ;# bit 2 send 0
1104   451C DB FE           IN      A,($FE)         ; signal to 0 /on
1105   451E             
1106   451E                 ;# bit 3 start
1107   451E CB 01           RLC C       ; 8
1108   4520 38 34           JR C, csendH3 ; 12/7
1109   4522 D8              ret c        ; 11/5 dummy for symmetric timing
1110   4523                 ;# bit 3 send 0
1111   4523 DB FE           IN      A,($FE)         ; signal to 0 /on
1112   4525             
1113   4525                 ;# bit 4 start
1114   4525 CB 01           RLC C       ; 8
1115   4527 38 37           JR C, csendH4 ; 12/7
1116   4529 D8              ret c        ; 11/5 dummy for symmetric timing
1117   452A                 ;# bit 4 send 0
1118   452A DB FE           IN      A,($FE)         ; signal to 0 /on
1119   452C             
1120   452C C9              ret
1121   452D             
1122   452D             
1123   452D             csendH1:    ;# bit 1 send 1
1124   452D D3 FF           OUT     ($FF),A         ; signal to 1 /off
1125   452F             
1126   452F                 ;# bit 2 start
1127   452F CB 01           RLC C       ; 8
1128   4531 38 12           JR C, csendH2 ; 12/7
1129   4533 D8              ret c        ; 11/5 dummy for symmetric timing
1130   4534                 ;# bit 2 send 0
1131   4534 DB FE           IN      A,($FE)         ; signal to 0 /on
1132   4536             
1133   4536                 ;# bit 3 start
1134   4536 CB 01           RLC C       ; 8
1135   4538 38 1C           JR C, csendH3 ; 12/7
1136   453A D8              ret c        ; 11/5 dummy for symmetric timing
1137   453B                 ;# bit 3 send 0
1138   453B DB FE           IN      A,($FE)         ; signal to 0 /on
1139   453D             
1140   453D                 ;# bit 4 start
1141   453D CB 01           RLC C       ; 8
1142   453F 38 1F           JR C, csendH4 ; 12/7
1143   4541 D8              ret c        ; 11/5 dummy for symmetric timing
1144   4542                 ;# bit 4 send 0
1145   4542 DB FE           IN      A,($FE)         ; signal to 0 /on
1146   4544 C9              ret
1147   4545             
1148   4545             csendH2:    ;# bit 2 send 1
1149   4545 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1150   4547             
1151   4547                 ;# bit 3 start
1152   4547 CB 01           RLC C       ; 8
1153   4549 38 0B           JR C, csendH3 ; 12/7
1154   454B D8              ret c        ; 11/5 dummy for symmetric timing
1155   454C                 ;# bit 3 send 0
1156   454C DB FE           IN      A,($FE)         ; signal to 0 /on
1157   454E             
1158   454E                 ;# bit 4 start
1159   454E CB 01           RLC C       ; 8
1160   4550 38 0E           JR C, csendH4 ; 12/7
1161   4552 D8              ret c        ; 11/5 dummy for symmetric timing
1162   4553                 ;# bit 4 send 0
1163   4553 DB FE           IN      A,($FE)         ; signal to 0 /on
1164   4555 C9              ret
1165   4556             
1166   4556             csendH3:    ;# bit 3 send 1
1167   4556 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1168   4558             
1169   4558                 ;# bit 4 start
1170   4558 CB 01           RLC C       ; 8
1171   455A 38 04           JR C, csendH4 ; 12/7
1172   455C D8              ret c        ; 11/5 dummy for symmetric timing
1173   455D                 ;# bit 4 send 0
1174   455D DB FE           IN      A,($FE)         ; signal to 0 /on
1175   455F C9              ret
1176   4560             
1177   4560             csendH4:    ;# bit 4 send 1
1178   4560 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1179   4562 C9              ret
1180   4563             
1181   4563             DRIVER_END:
1182   4563             
1183   4563 76             db $76   ;N/L 
1184   4564             
1185   4564             line10:
1186   4564 00 0A          db 0,10  ;line number 
1187   4566 13 00          dw dfile-$-2  ;line length 
1188   4568 F5             db $f5   ;PRINT 
1189   4569 D4             db $d4   ;USR 
1190   456A 1D             db $1d   ;1 
1191   456B 22             db $22   ;6 
1192   456C 21             db $21   ;5 
1193   456D 1D             db $1d   ;1 
1194   456E 20             db $20   ;4 
1195   456F 7E             db $7e   ;FP mark 
1196   4570 8F             db $8f   ;5 bytes FP number 
1197   4571 01             db $01   ; 
1198   4572 04             db $04   ; 
1199   4573 00             db $00   ; 
1200   4574 00             db $00   ; 
1201   4575 1A             db $1a   ; ,
1202   4576 0B             db $0b   ; "
1203   4577 2D             db c_H   ; Help
1204   4578               
1205   4578              ;  db c_I   ; I 10000 install
1206   4578                ;db c_I   ; TTTT2 = QLOAD test
1207   4578                ;db c_T   ; SNNN = dummy save for testing
1208   4578                ;db c_S   ; STST,1024,100 binsave
1209   4578                ;db c_T   ; LTST,1024   binload
1210   4578              ;  db 0   ; 
1211   4578              ;  db c_0+1   ; 
1212   4578              ;  db c_0+0   ; 
1213   4578              ;  db c_0+0   ; 
1214   4578              ;  db c_0+0   ; 
1215   4578              ;  db c_0+0   ; 
1216   4578             ;   db 26
1217   4578             ;   db c_0+1   ; 
1218   4578             ;   db c_0+0   ; 
1219   4578             ;   db c_0+0   ; 
1220   4578 0B             db $0b   ; "
1221   4579 76             db $76   ;N/L 
1222   457A 76             db $76   ;N/L 
1223   457B             
1224   457B             
1225   457B                
1226   457B             ;- Display file -------------------------------------------- 
1227   457B              
1228   457B             dfile: 
1229   457B 76             db $76 
1230   457C 3F 3D          db c_Z,c_X,
1231   457E 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1231   4582 76 76 76 76 
1232   4586 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1232   458A 76 76 76 76 
1233   458E 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1233   4592 76 76 76 76 
1234   4596              
1235   4596             ;- BASIC-Variables ---------------------------------------- 
1236   4596              
1237   4596             var: 
1238   4596 80             db $80 
1239   4597              
1240   4597             ;- End of program area ---------------------------- 
1241   4597             
1242   4597             last: 
1243   4597              
1244   4597                end 
tasm: Number of errors = 0
