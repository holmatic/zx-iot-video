0001   0000             ; SYSINFO81 
0002   0000             ; 	GPL
0003   0000             ; 	Oliver Lange
0004   0000             ; 	Version 1.0.1
0005   0000             
0006   0000             ; Compile with "tasm -80 -b wspdrv.asm wspdrv.p" 
0007   0000             
0008   0000             
0009   0000             ; driver for wespi
0010   0000             ;
0011   0000             
0012   0000             
0013   0000              
0014   0000             #define db .byte ;  cross-assembler definitions 
0015   0000             #define dw .word 
0016   0000             #define ds .block 
0017   0000             #define org .org 
0018   0000             #define end .end 
0019   0000             
0020   0000             
0021   0000             
0022   0000             #define ADDR_DISABLE 0
0023   0000             #define UPDATE	01FCh	; LOAD/SAVE adress update subroutine in ROM
0024   0000             
0025   0000             ;;#define VERBOSE 1
0026   0000              
0027   4009             org     $4009 ; BASIC PROGRAMM
0028   4009             ;= System variables ============================================ 
0029   4009              
0030   4009 00             db 0     	;VERSN 
0031   400A 00 00          dw 0     	;E_PPC 
0032   400C 0F 45          dw dfile      ;D_FILE 
0033   400E 10 45          dw dfile+1    ;DF_CC 
0034   4010 2A 45          dw var   	;VARS 
0035   4012 00 00          dw 0     	;DEST 
0036   4014 2B 45          dw var+1      ;E_LINE 
0037   4016 2A 45          dw last-1     ;c_ADD 
0038   4018 00 00          dw 0     	;X_PTR 
0039   401A 2B 45          dw last  	;STKBOT 
0040   401C 2B 45          dw last  	;STKEND 
0041   401E 00             db 0     	;BERG 
0042   401F 5D 40          dw membot     ;MEM 
0043   4021 00             db 0     ;not used 
0044   4022 02             db 2     ;DF_SZ 
0045   4023 01 00          dw 1     ;S_TOP 
0046   4025 FF FF FF       db $FF,$FF,$FF     ;LAST_K 
0047   4028 37             db 55    ;MARGIN 
0048   4029 F8 44          dw line10     ;NXTLIN   line10   dfile
0049   402B 00 00          dw 0     ;OLDPPC 
0050   402D 00             db 0     ;FLAGX 
0051   402E 00 00          dw 0     ;STRLEN 
0052   4030 8D 0C          dw $0C8D      ;T_ADDR 
0053   4032 00 00          dw 0     ;SEED 
0054   4034 FF FF          dw $FFFF      ;FRAMES 
0055   4036 00 00          db 0,0   ;COORDS 
0056   4038 BC             db $BC   ;PR_CC 
0057   4039 21 18          db 33,24      ;S_POSN 
0058   403B 40             db 01000000B  ;CDFLAG 
0059   403C                ds 33    ;Print buffer --- now used for loader code, all loaded programs need to have the same !
0060   405D             
0061   405D             membot: 
0062   405D                ds 30    ;Calculator�s memory area 
0063   407B                ds 2     ;not used 
0064   407D              
0065   407D             ;= First BASIC line, asm code ================================== 
0066   407D              
0067   407D             line0: 
0068   407D 00 00          db 0,0   ;line number 
0069   407F 77 04          dw line10-$-2 ;line length 
0070   4081 EA             db $ea   ; REM 
0071   4082             
0072   4082             
0073   4082             #define ELINE	4014h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0074   4082             #define ELINEHI	4015h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0075   4082             
0076   4082             #define SHOW	0207h  ; ROM-Routinen
0077   4082             #define FAST	02E7h
0078   4082             #define RCLS	0A2Ah
0079   4082             #define GETKEY	02BBh
0080   4082             
0081   4082             
0082   4082             #DEFINE RST_PRTCHAR RST 10H
0083   4082             #DEFINE c_SPACE 0
0084   4082             #DEFINE c_NEWLINE 76H
0085   4082             #DEFINE c_0 1CH
0086   4082             
0087   4082             #DEFINE c_A 26H
0088   4082             #DEFINE c_B c_A+1
0089   4082             #DEFINE c_C c_A+2
0090   4082             #DEFINE c_D c_A+3
0091   4082             #DEFINE c_E c_A+4
0092   4082             #DEFINE c_F c_A+5
0093   4082             #DEFINE c_G c_A+6
0094   4082             #DEFINE c_H c_A+7
0095   4082             #DEFINE c_I c_A+8
0096   4082             #DEFINE c_J c_A+9
0097   4082             #DEFINE c_K c_J+1
0098   4082             #DEFINE c_L c_J+2
0099   4082             #DEFINE c_M c_J+3
0100   4082             #DEFINE c_N c_J+4
0101   4082             #DEFINE c_O c_J+5
0102   4082             #DEFINE c_P c_J+6
0103   4082             #DEFINE c_Q c_J+7
0104   4082             #DEFINE c_R c_J+8
0105   4082             #DEFINE c_S c_J+9
0106   4082             #DEFINE c_T c_S+1
0107   4082             #DEFINE c_U c_S+2
0108   4082             #DEFINE c_V c_S+3
0109   4082             #DEFINE c_W c_S+4
0110   4082             #DEFINE c_X c_S+5
0111   4082             #DEFINE c_Y c_S+6
0112   4082             #DEFINE c_Z c_S+7
0113   4082             
0114   4082             #define UFM_ERRNO 16434 ; Definiert in UFM, Fehlercode 1 Byte (eigentlich SEED)
0115   4082             #define UFM_CMDBUF 16444 ; Definiert in UFM, 32 Byte, alternative Kommando�bergabe (eigentlich PRBUF)
0116   4082             #define UFM_COORDS 16438 ; L�ngen�bergabe 2 Byte (eigentlich COORDS)
0117   4082             
0118   4082             
0119   4082             ;
0120   4082             ;   === Main entry point ====
0121   4082             ;
0122   4082             DRIVER_START:
0123   4082             BASIC_START:
0124   4082             AA45:
0125   4082 CD 30 44    	CALL NAME	; get command line arg
0126   4085 18 1B       	JR BASIC_CONT
0127   4087 00          	NOP
0128   4088 00          	NOP
0129   4089 00          	NOP
0130   408A             
0131   408A             CALL_START:	; (IN UFM als START_ADDR+6 festgelegt)
0132   408A 21 3C 40    	LD HL,UFM_CMDBUF
0133   408D E5              PUSH HL
0134   408E                 ;  get length in BC by parsing for '"' or so..
0135   408E 01 00 00        LD   BC,0
0136   4091             ENDPRSLP:
0137   4091 7E              LD   A,(HL)
0138   4092 FE 0B           CP   11     ; is " ?
0139   4094 28 04           JR   Z, EXITPRSLP
0140   4096 03              INC  BC
0141   4097 23              INC  HL
0142   4098 18 F7           JR   ENDPRSLP
0143   409A             EXITPRSLP:
0144   409A E1              POP  HL ; original pointer
0145   409B             AA44:
0146   409B CD BA 40    	CALL GENER_START
0147   409E 32 32 40    	LD (UFM_ERRNO),A
0148   40A1 C9          	RET
0149   40A2             
0150   40A2             BASIC_CONT:
0151   40A2             AA01:
0152   40A2 CD BA 40    	CALL GENER_START ; A is 0 for ok, !=0 for error
0153   40A5 A7          	AND A
0154   40A6 28 0F       	JR Z,BAS_OK
0155   40A8 3E 2A       	LD A,c_E		; Ausgabe ERR
0156   40AA D7          	RST 10h 
0157   40AB 3E 37       	LD A,c_R
0158   40AD D7          	RST 10h
0159   40AE 3E 37           LD A,c_R
0160   40B0 D7          	RST 10h
0161   40B1 3E 76           LD A,c_NEWLINE
0162   40B3 D7          	RST 10h
0163   40B4                 ; exit
0164   40B4 AF              XOR A
0165   40B5 CF          	RST 08h
0166   40B6 09              db  09h             ; Error Report: Invalid argument
0167   40B7             	;db 0FFh
0168   40B7             
0169   40B7             BAS_OK:
0170   40B7             	; RET  ; TODO check if RET or better RST8 with -1
0171   40B7 AF              XOR A		; sonst zurueck nach BASIC
0172   40B8 CF          	RST 08h
0173   40B9 FF          	db 0FFh
0174   40BA             	
0175   40BA             
0176   40BA             GENER_START: ; Interpreting the string independent of its origin, on ret A=0 for okay, BC retval to basic
0177   40BA 7E          	LD A,(HL)   ; HL=start, BC=length
0178   40BB 23              INC  HL
0179   40BC 0B              DEC  BC
0180   40BD             AA00:
0181   40BD 11 E0 40        LD   DE,GENER_END
0182   40C0 D5              PUSH DE     ; ret adddess
0183   40C1             ;	CP c_I		; Info
0184   40C1             ;	JP Z,INFO1
0185   40C1 FE 38       	CP c_S		; Save
0186   40C3             AA41:
0187   40C3 CA 9C 42    	JP Z,SAVE1
0188   40C6 FE 31       	CP c_L		; Load
0189   40C8             AA42:
0190   40C8 CA CD 41    	JP Z,LOAD1
0191   40CB             ;	CP 29h		; ist es ein D;
0192   40CB             ;	JP Z,DIR1
0193   40CB             ;	CP 3Bh		; ist es ein V (UFM)
0194   40CB             ;	JP Z,DIRV1
0195   40CB             ;	CP 30h		; ist es ein K (UFM)
0196   40CB             ;	JP Z,DIRK1
0197   40CB             ;	CP 37h		; ist es ein R
0198   40CB             ;	JP Z,RENAM1
0199   40CB             ;	CP 2Ah		; ist es ein E
0200   40CB             ;	JP Z,ERAS1
0201   40CB FE 2E       	CP c_I		;  I
0202   40CD             AA02:
0203   40CD CA E8 40    	JP Z,INST_RELOC
0204   40D0 FE 39       	CP c_T		; Test, return 0...1023 dependng on number of correct bytes
0205   40D2             AA43:
0206   40D2 CA 70 42    	JP Z,TESTPATTERN
0207   40D5 FE 2D       	CP c_H		; Help
0208   40D7             AA03:
0209   40D7 CA 9B 43    	JP Z,HLP
0210   40DA FE 0F       	CP 0Fh		; ist es ein ?
0211   40DC             AA04:
0212   40DC CA 9B 43    	JP Z,HLP
0213   40DF C9              ret 
0214   40E0             
0215   40E0             GENER_END:
0216   40E0 F5              PUSH AF ; holds our error status
0217   40E1 C5              PUSH BC ; ret value...
0218   40E2 CD 07 02    	CALL SHOW
0219   40E5 C1              POP  BC
0220   40E6 F1              POP  AF
0221   40E7 C9          	RET
0222   40E8             	
0223   40E8             INST_RELOC:
0224   40E8                 ; address with new memory location follows. Cpoies the driver and corrects the absolute adresses accordingly
0225   40E8             AA09:
0226   40E8 CD 31 42        CALL PARS_DEC_NUM   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0227   40EB 3E 01           LD   A,1
0228   40ED C0              RET  NZ
0229   40EE D5              PUSH DE
0230   40EF CD E7 02    	CALL FAST	; go to fast mode so we can use index regs
0231   40F2 D1              POP  DE
0232   40F3 DD E5           PUSH IX     ; save IX till end
0233   40F5 D5              PUSH DE
0234   40F6 DD E1           POP  IX     ; new start addr in IX, will need it quite often
0235   40F8                 ; copy RAW driver
0236   40F8             AA06:
0237   40F8 21 82 40        LD HL,DRIVER_START
0238   40FB 01 75 04        LD BC,DRIVER_END-DRIVER_START
0239   40FE ED B0           LDIR
0240   4100                 ; correct abs addr occurrences, all in this table:
0241   4100             AA07:
0242   4100 21 47 41        LD HL, RELOC_TABLE
0243   4103             RLCLOOP:
0244   4103 5E              LD   E,(HL)
0245   4104 23              INC  HL
0246   4105 56              LD   D,(HL)
0247   4106 23              INC  HL
0248   4107 7A              LD   A,D
0249   4108 B3              OR  E
0250   4109 28 1C           JR   Z, ENDRLCCP    ; null end marker
0251   410B E5              PUSH HL ; next RELOC_TABLE pos
0252   410C                 ; DE is position of the addr tag relative to start
0253   410C DD E5           PUSH IX
0254   410E E1              POP  HL
0255   410F 19              ADD  HL,DE
0256   4110                 ; HL is the absolute label pos to modify
0257   4110 E5              PUSH HL ; need it later to write
0258   4111 5E              LD   E,(HL) 
0259   4112 23              INC  HL
0260   4113 56              LD   D,(HL)
0261   4114             AA05:
0262   4114 21 82 40        LD   HL, DRIVER_START
0263   4117 EB              EX   DE,HL
0264   4118 A7          	AND A		; clear carry
0265   4119 ED 52       	SBC HL,DE	; actual address minus old offset
0266   411B             
0267   411B                 ; HL is relative addr
0268   411B DD E5           PUSH IX
0269   411D D1              POP  DE
0270   411E 19              ADD  HL,DE  ; add new offset
0271   411F EB              EX   DE,HL
0272   4120                 ; DE is new abs addr
0273   4120 E1              POP  HL
0274   4121 73              LD   (HL),E
0275   4122 23              INC  HL
0276   4123 72              LD   (HL),D
0277   4124 E1              POP HL ; restore RELOC_TABLE pos
0278   4125 18 DC           JR RLCLOOP
0279   4127             ENDRLCCP:
0280   4127 DD E1           POP  IX
0281   4129 AF              XOR  A
0282   412A 01 75 04        LD   BC,DRIVER_END-DRIVER_START
0283   412D C9              RET
0284   412E              
0285   412E             
0286   412E             PRINTHEX:
0287   412E F5          	PUSH AF
0288   412F E5          	PUSH HL
0289   4130 C5          	PUSH BC
0290   4131 4F          	LD C,A		; SAVE
0291   4132 CB 3F       	SRL A
0292   4134 CB 3F       	SRL A
0293   4136 CB 3F       	SRL A
0294   4138 CB 3F       	SRL A
0295   413A C6 1C       	ADD A,1CH	; Offset to '0'
0296   413C D7          	RST 10H
0297   413D 79          	LD A,C
0298   413E E6 0F       	AND	0FH		; MASK
0299   4140 C6 1C       	ADD A,1CH	; Offset to '0'
0300   4142 D7          	RST 10H
0301   4143 C1          	POP BC
0302   4144 E1          	POP HL
0303   4145 F1          	POP AF
0304   4146 C9          	RET
0305   4147             
0306   4147             
0307   4147             RELOC_TABLE:
0308   4147              ;   dw 0
0309   4147 3C 00           dw AA00+1-DRIVER_START
0310   4149 21 00           dw AA01+1-DRIVER_START
0311   414B 4C 00           dw AA02+1-DRIVER_START
0312   414D 56 00           dw AA03+1-DRIVER_START
0313   414F 5B 00           dw AA04+1-DRIVER_START
0314   4151 93 00           dw AA05+1-DRIVER_START
0315   4153 77 00           dw AA06+1-DRIVER_START
0316   4155 7F 00           dw AA07+1-DRIVER_START
0317   4157 1A 03           dw AA08+1-DRIVER_START
0318   4159 67 00           dw AA09+1-DRIVER_START
0319   415B             
0320   415B 4E 01           dw AA10+1-DRIVER_START
0321   415D 5B 01           dw AA11+1-DRIVER_START
0322   415F 5E 01           dw AA12+1-DRIVER_START
0323   4161 6A 01           dw AA13+1-DRIVER_START
0324   4163 73 01           dw AA14+1-DRIVER_START
0325   4165 7F 01           dw AA15+1-DRIVER_START
0326   4167 89 01           dw AA16+1-DRIVER_START
0327   4169 A6 01           dw AA17+1-DRIVER_START
0328   416B F1 01           dw AA18+1-DRIVER_START
0329   416D FC 01           dw AA19+1-DRIVER_START
0330   416F             
0331   416F 05 02           dw AA20+1-DRIVER_START
0332   4171 1D 02           dw AA21+1-DRIVER_START
0333   4173 27 02           dw AA22+1-DRIVER_START
0334   4175 3C 02           dw AA23+1-DRIVER_START
0335   4177 46 02           dw AA24+1-DRIVER_START
0336   4179 54 02           dw AA25+1-DRIVER_START
0337   417B 62 02           dw AA26+1-DRIVER_START
0338   417D 65 02           dw AA27+1-DRIVER_START
0339   417F 71 02           dw AA28+1-DRIVER_START
0340   4181 79 02           dw AA29+1-DRIVER_START
0341   4183             
0342   4183 46 03           dw AA30+1-DRIVER_START
0343   4185 50 03           dw AA31+1-DRIVER_START
0344   4187 82 03           dw AA32+1-DRIVER_START
0345   4189 85 03           dw AA33+1-DRIVER_START
0346   418B 8F 03           dw AA34+1-DRIVER_START
0347   418D DD 03           dw AA35+1-DRIVER_START
0348   418F E9 03           dw AA36+1-DRIVER_START
0349   4191 F5 03           dw AA37+1-DRIVER_START
0350   4193 01 04           dw AA38+1-DRIVER_START
0351   4195 0D 04           dw AA39+1-DRIVER_START
0352   4197             
0353   4197 19 04           dw AA40+1-DRIVER_START
0354   4199 42 00           dw AA41+1-DRIVER_START
0355   419B 47 00           dw AA42+1-DRIVER_START
0356   419D 51 00           dw AA43+1-DRIVER_START
0357   419F 1A 00           dw AA44+1-DRIVER_START
0358   41A1 01 00           dw AA45+1-DRIVER_START
0359   41A3 00 00           dw 0    ; final
0360   41A5             
0361   41A5             
0362   41A5             
0363   41A5             CHECKCOMMA:  ; Z is set when comma seperator found in string, NZ if not, uses A
0364   41A5                 ; BC =0?
0365   41A5 AF              XOR  A
0366   41A6 B9              CP   C
0367   41A7 20 02           JR   NZ,CHKK_CONT
0368   41A9 3C              INC  A ; clear the Z flag
0369   41AA C9              RET     ; no match till end
0370   41AB             CHKK_CONT:
0371   41AB 7E              LD   A, (HL)
0372   41AC FE 1A           CP   26     ; comma
0373   41AE C8              RET  z
0374   41AF FE 19           CP   25     ; also check for semicolon
0375   41B1 C8              RET  z
0376   41B2 23              INC  HL
0377   41B3 0B              DEC  BC
0378   41B4 18 EF           JR CHECKCOMMA
0379   41B6             
0380   41B6             
0381   41B6             SKIPEMPTY:  ; Z is set when comma seperator found in string, NZ if not, uses A
0382   41B6                 ; BC =0?
0383   41B6 AF              XOR  A
0384   41B7 B9              CP   C
0385   41B8 20 05           JR   NZ,CHKE_CONT
0386   41BA B8              CP   B
0387   41BB 20 02           JR   NZ,CHKE_CONT
0388   41BD 3C              INC  A ; clear the Z flag
0389   41BE C9              RET     ; no match till end
0390   41BF             CHKE_CONT:
0391   41BF BE              CP   (HL)
0392   41C0 C0              RET  NZ ; not empty,leave
0393   41C1 23              INC  HL
0394   41C2 0B              DEC  BC
0395   41C3 18 F1           JR SKIPEMPTY
0396   41C5             
0397   41C5             PRINTA:
0398   41C5 E5              PUSH HL
0399   41C6 D5              PUSH DE
0400   41C7 C5              PUSH BC
0401   41C8 D7              RST 10H
0402   41C9 C1              POP  BC
0403   41CA D1              POP  DE
0404   41CB E1              POP  HL
0405   41CC C9              RET
0406   41CD                 
0407   41CD             
0408   41CD             LOAD1:
0409   41CD             	; HL points to arg string, BC number of chars
0410   41CD E5              PUSH HL  ; orig pos of args (w/o prefix T)
0411   41CE C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0412   41CF                 ; Check if we have contact
0413   41CF             AA10:    
0414   41CF CD C7 43        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0415   41D2 A7              AND A
0416   41D3                 ; Send LOAD request
0417   41D3 C1              POP  BC
0418   41D4 E1              POP  HL ; recover name pointer/length
0419   41D5 28 4B           JR   Z, LD_ERR ; NO CONTACT after TRY_HANDSHAKE
0420   41D7 E5              PUSH HL  ; and again store for binload
0421   41D8 C5              PUSH BC  ; 
0422   41D9             
0423   41D9 41              ld   B,C ; length, assume <256
0424   41DA 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0425   41DC             AA11:
0426   41DC CD 44 44        CALL SEND_PACKET
0427   41DF             
0428   41DF                 ; now retrieve key, must be 123
0429   41DF             AA12:
0430   41DF CD 16 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0431   41E2 FE 7B           CP  123
0432   41E4 20 3A           JR NZ,LD_ERR2
0433   41E6 06 04           LD   B,4
0434   41E8 7E              LD  A,(HL)  ; dummy for timing
0435   41E9              
0436   41E9             LOADELY1:         ;    //47 delay between the header bytes
0437   41E9 10 FE           DJNZ LOADELY1
0438   41EB             
0439   41EB                 ; now retrieve length, 0 for error
0440   41EB             AA13:
0441   41EB CD 16 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0442   41EE 6F              LD   L,A
0443   41EF 06 05           LD   B,5
0444   41F1             
0445   41F1             LOADELY2:         ;    //60 delay between the length bytes
0446   41F1 10 FE           DJNZ LOADELY2
0447   41F3             
0448   41F3 00              NOP
0449   41F4             AA14:
0450   41F4 CD 16 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0451   41F7 67              LD   H,A
0452   41F8 B5              OR   L
0453   41F9 28 25           JR Z,LD_ERR2
0454   41FB EB              EX   DE,HL
0455   41FC                 ; Here we have DE= len
0456   41FC                 ; get addr
0457   41FC C1              POP  BC
0458   41FD E1              POP  HL ; recover name pointer/length
0459   41FE D5              PUSH DE             ; length, will go to BC below
0460   41FF D5              PUSH DE             ; length, again, for end result
0461   4200             
0462   4200             
0463   4200                 ;  test if saving binary or regular basic
0464   4200             AA15:
0465   4200 CD A5 41        CALL CHECKCOMMA
0466   4203 28 20           JR   Z, BINLOAD
0467   4205             
0468   4205                 ; LOAD BASIC program if not BINLOAD, set addr
0469   4205 21 09 40    	LD HL,4009h		; 
0470   4208 1E 01           LD   E,1        ; mark as basic load
0471   420A             
0472   420A             LOADLOOP:
0473   420A                 ; timing  - 74 between calls seems to be more reliable than 70!
0474   420A             AA16:
0475   420A CD 16 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0476   420D 77              LD   (HL),A
0477   420E 77              LD   (HL),A ; dummy for timing
0478   420F 23              INC  HL
0479   4210 C1              POP  BC     ; get remaining length
0480   4211 0B              DEC  BC
0481   4212 79              LD   A,C
0482   4213 B0              OR   B
0483   4214 28 03           JR Z, LD_END
0484   4216 C5              PUSH BC
0485   4217 18 F1           JR  LOADLOOP
0486   4219             LD_END:  
0487   4219 C1              POP  BC ; orig length
0488   421A AF              XOR  A
0489   421B BB              CP   E  ; 0 for binary
0490   421C C8              RET   Z ; normal return for binload with length in BC
0491   421D                 ; end for BASIC loader
0492   421D D1              POP  DE ; dummy, ret addr
0493   421E CF          	RST 08h ;
0494   421F FF          	db 0FFh
0495   4220             
0496   4220             
0497   4220             LD_ERR2:
0498   4220 D1              POP  DE ; dummy
0499   4221 D1              POP  DE ; dummy
0500   4222             LD_ERR:
0501   4222 3E 01           LD   A,1
0502   4224 C9              RET ; BC WILL be at maximum now
0503   4225             
0504   4225             
0505   4225             
0506   4225             BINLOAD: ; HL points to the comma in arg string, now parse addr, length
0507   4225 23              INC  HL
0508   4226 0D              DEC  C
0509   4227             AA17:
0510   4227 CD 31 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0511   422A 20 F4           JR NZ, LD_ERR2   ; parse error
0512   422C                 ; addr in DE
0513   422C EB              EX   DE,HL
0514   422D 1E 00           LD   E,0    ; mark as binary
0515   422F 18 D9           JR LOADLOOP
0516   4231             
0517   4231             
0518   4231             
0519   4231             ; parse a decimal number
0520   4231             PARS_DEC_NUM:   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0521   4231 11 00 00    	LD DE, 0
0522   4234 AF              XOR  A
0523   4235 B9              CP   C
0524   4236 28 35           JR Z,PARSFAIL
0525   4238             
0526   4238             PARS_LLOOP:     ; look for first number
0527   4238 7E          	LD A,(HL)
0528   4239 A7          	AND A
0529   423A 28 29       	JR Z, PARS_SKIPWS ; skip whitespace
0530   423C             PARS_LLP2:
0531   423C D6 1C       	SUB 01ch	;"0"
0532   423E 38 2D       	JR C,PARSFAIL
0533   4240 FE 0A       	CP 10
0534   4242 30 29       	JR NC,PARSFAIL
0535   4244             	; have a digit in A,
0536   4244 E5          	PUSH HL
0537   4245             	; DE times ten
0538   4245 62          	LD H,D      ; now in both HL and DE
0539   4246 6B          	LD L,E
0540   4247 29          	ADD HL,HL
0541   4248 29          	ADD HL,HL
0542   4249 29          	ADD HL,HL ; times 8 so far
0543   424A 19          	ADD HL,DE
0544   424B 19          	ADD HL,DE
0545   424C             	; Add new digit
0546   424C 16 00       	LD D,0
0547   424E 5F          	LD E,A
0548   424F 19          	ADD HL,DE
0549   4250 EB          	EX DE,HL    ; new value of DE
0550   4251 E1          	POP HL  ; pointer to argline back in HL
0551   4252 23          	INC HL
0552   4253 0D          	DEC C
0553   4254 28 15           JR Z,PARSDONE
0554   4256 7E          	LD A,(HL)   ; load next char to see if end
0555   4257 FE 1A           CP   26 ;  ','
0556   4259 28 10           JR Z,PARSDONE
0557   425B FE 0E           CP   14 ;  ';'
0558   425D 28 0C           JR Z,PARSDONE
0559   425F FE 0B           CP   11 ;  '"'
0560   4261 28 08           JR Z,PARSDONE
0561   4263 18 D7       	JR PARS_LLP2 
0562   4265             PARS_SKIPWS:
0563   4265 23          	INC HL
0564   4266 0D          	DEC C
0565   4267 28 04           JR Z,PARSFAIL
0566   4269 18 CD       	JR PARS_LLOOP 
0567   426B             
0568   426B             PARSDONE:
0569   426B AF              XOR  A
0570   426C C9          	RET
0571   426D             PARSFAIL:
0572   426D AF              XOR  A
0573   426E 3C              INC  A
0574   426F C9          	RET
0575   4270             
0576   4270             
0577   4270             TESTPATTERN:
0578   4270             	; HL points to arg string, BC number of chars
0579   4270 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0580   4271 C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0581   4272                 ; Check if we have contact
0582   4272             AA18:    
0583   4272 CD C7 43        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0584   4275 A7              AND A
0585   4276                 ; Send LOAD request
0586   4276 C1              POP  BC
0587   4277 E1              POP  HL ; recover name pointer/length
0588   4278 28 1C           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0589   427A             
0590   427A 41              ld   B,C ; length, assume <256
0591   427B 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0592   427D             AA19:
0593   427D CD 44 44        CALL SEND_PACKET
0594   4280             
0595   4280                 ; now retrieve 1024 bytes and see how many are correct
0596   4280                 ; gap between byte calls should be 77+12+7 - 17-10 = 69 clocks
0597   4280 01 00 00        LD   BC,0
0598   4283             TESTBLOOP:
0599   4283 C5              PUSH BC
0600   4284 00              NOP         ; timing adjust 66/70
0601   4285 00              NOP         ; timing adjust 70/74 - 74 seems to be more reliable than 70!
0602   4286             AA20:
0603   4286 CD 16 44        CALL QLD_GETBYTE    ; uses BC D, result in A
0604   4289 C1              POP  BC
0605   428A B9              CP   C  ; incomming data in A is 0,1,2,3,4...255,0,1... as byte
0606   428B 3E 00           LD   A,0 ; not affect flags, test never reports errors to better automatize
0607   428D C0              RET  NZ ; report BC at point of first failure
0608   428E 03              INC  BC
0609   428F 3E 10           LD   A,16 ; 4kbyte testsize
0610   4291 B8              CP   B
0611   4292 20 EF           JR   NZ, TESTBLOOP
0612   4294 AF              XOR  A
0613   4295 C9              RET ; BC WILL be at maximum now
0614   4296             
0615   4296             
0616   4296             
0617   4296             ERREXIT:
0618   4296 3E 01           LD   A,1
0619   4298 01 00 00        LD   BC,0
0620   429B C9              RET
0621   429C             
0622   429C             SAVE1:
0623   429C             	; HL points to arg string, BC number of chars
0624   429C E5              PUSH HL  ; orig pos of args (w/o prefix S)
0625   429D C5              PUSH BC  ; orig lenght of args (w/o prefix S)
0626   429E             
0627   429E             
0628   429E             ;    LD   A, c_S
0629   429E             ;    CALL PRINTA
0630   429E             
0631   429E                 ; Check if we have contact
0632   429E             AA21:   
0633   429E CD C7 43        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0634   42A1                 ; Send SAVE request
0635   42A1 C1              POP  BC
0636   42A2 E1              POP  HL ; recover name pointer/length
0637   42A3                 ; evauate connect result
0638   42A3 A7              AND A
0639   42A4 28 F0           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0640   42A6             
0641   42A6                 ; again store original argument string, will need it now and when sending name
0642   42A6 E5              PUSH HL
0643   42A7 C5              PUSH BC
0644   42A8             
0645   42A8                 ;  test if saving binary or regular basic
0646   42A8             AA22:
0647   42A8 CD A5 41        CALL CHECKCOMMA
0648   42AB 28 43           JR   Z, BINSAVE
0649   42AD             
0650   42AD                 ; SAVE BASIC program if not BINSAVE, pre-calc addr,size into HL and BC
0651   42AD 11 09 40    	LD DE,4009h		; Get length
0652   42B0 2A 14 40    	LD HL,(ELINE)	
0653   42B3 A7          	AND A		; clear carry
0654   42B4 ED 52       	SBC HL,DE	; HL=length
0655   42B6 44          	LD B,H
0656   42B7 4D          	LD C,L
0657   42B8 EB          	EX DE,HL	; Now HL=Start, BC=length
0658   42B9             
0659   42B9             SAVE_CONT: ;continue common path of BIN and BASIC save
0660   42B9 D9              EXX     ; store payload addr and length for now
0661   42BA EB          	EX DE,HL	; HL' must be restored, save in DE'
0662   42BB C1              POP  BC
0663   42BC E1              POP  HL ; recover name pointer/length
0664   42BD             AA23:
0665   42BD CD B6 41        CALL SKIPEMPTY 
0666   42C0 AF              XOR  A
0667   42C1 B9              CP   C
0668   42C2 28 40           JR   Z, ERREXIT3 ; NO NAME
0669   42C4 41              ld   B,C ; length, assume <256
0670   42C5 0E 5B           ld   C,91 ; packet ID ZX_QSAVE_TAG_SAVEPFILE
0671   42C7             AA24:
0672   42C7 CD 44 44        CALL SEND_PACKET
0673   42CA EB          	EX DE,HL	; HL' must be restored, was saved in DE'
0674   42CB D9              EXX ; Recover, now HL=Start, BC=length
0675   42CC             	
0676   42CC             SVSENDFUL:
0677   42CC AF              XOR  A
0678   42CD B8              CP   B
0679   42CE 28 0C           JR   Z, SVSENDLAST
0680   42D0                 ; send full packets
0681   42D0 C5              PUSH BC
0682   42D1 06 00           LD   B,0    ; 256 bytes
0683   42D3 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0684   42D5             AA25:
0685   42D5 CD 44 44        CALL SEND_PACKET
0686   42D8 C1              POP  BC
0687   42D9 05              DEC  B
0688   42DA 18 F0           JR   SVSENDFUL
0689   42DC             
0690   42DC             SVSENDLAST:
0691   42DC AF              XOR  A
0692   42DD B9              CP   C
0693   42DE 28 06           JR   Z, SVSENDEND
0694   42E0 41              LD   B,C ; length
0695   42E1 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0696   42E3             AA26:
0697   42E3 CD 44 44        CALL SEND_PACKET
0698   42E6             
0699   42E6             SVSENDEND:
0700   42E6             AA27:
0701   42E6 CD FC 43        CALL QS_FINAL_ACK   ; Z set for success
0702   42E9 20 AB           JR   NZ, ERREXIT
0703   42EB AF              XOR  A
0704   42EC 01 01 00        LD   BC, 1
0705   42EF C9          	RET
0706   42F0             
0707   42F0             
0708   42F0             BINSAVE: ; HL points to the comma in arg string, now parse addr, length
0709   42F0 23              INC  HL
0710   42F1 0D              DEC  C
0711   42F2             AA28:
0712   42F2 CD 31 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0713   42F5 20 13           JR NZ, BSERREXIT   ; parse error
0714   42F7 D5              PUSH DE ; store addr, from now on have to use BSERREXIT2 to stack-unwind here
0715   42F8 23              INC  HL
0716   42F9 0D              DEC  C
0717   42FA             AA29:
0718   42FA CD 31 42        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0719   42FD 20 0A           JR NZ, BSERREXIT2   ; parse error
0720   42FF                 ; length in DE
0721   42FF                 ; Now put HL=Start, BC=length
0722   42FF 42              LD   B,D
0723   4300 4B              LD   C,E
0724   4301 E1              POP  HL
0725   4302 18 B5           JR SAVE_CONT
0726   4304             
0727   4304             ERREXIT3:
0728   4304 EB          	EX DE,HL	; HL' must be restored, saved in DE'
0729   4305 D9              EXX ; Recover
0730   4306 3E 01           LD   A,1
0731   4308 C9          	RET
0732   4309             
0733   4309             BSERREXIT2:
0734   4309 D1              POP  DE
0735   430A             BSERREXIT:
0736   430A C1              POP  BC
0737   430B E1              POP  HL ; recover name pointer/length
0738   430C 3E 01           LD   A,1
0739   430E C9          	RET
0740   430F             
0741   430F             
0742   430F             HLPTXT:
0743   430F 3F 3D 00 3C 	db c_Z,c_X,0,c_W,c_E,c_S,c_P,c_I,0,c_D,c_R,c_I,c_V,c_E,c_R,0, c_0,27,c_0+1,c_0,c_0+1,c_NEWLINE
0743   4313 2A 38 35 2E 
0743   4317 00 29 37 2E 
0743   431B 3B 2A 37 00 
0743   431F 1C 1B 1D 1C 
0743   4323 1D 76 
0744   4325 76              db c_NEWLINE
0745   4326             ;	db "INFO  ",22h,"I",22h,0dh
0746   4326             ;	db "DIR   ",22h,"D",22h,0dh
0747   4326             ;	db "ERASE ",22h,"ENAME.P",22h,0dh
0748   4326             ;	db "MKDIR ",22h,"DMVERZ",22h,0dh
0749   4326             ;	db "RMDIR ",22h,"DEVERZ",22h,0dh
0750   4326             ;	db "CHDIR ",22h,"DCVERZ",22h,0dh
0751   4326 31 34 26 29 	db c_L,c_O,c_A,c_D, 0 , 0 , 0, 11, c_L, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0751   432A 00 00 00 0B 
0751   432E 31 33 26 32 
0751   4332 2A 0B 76 
0752   4335 38 26 3B 2A 	db c_S,c_A,c_V,c_E, 0 , 0 , 0, 11, c_S, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0752   4339 00 00 00 0B 
0752   433D 38 33 26 32 
0752   4341 2A 0B 76 
0753   4344 27 31 34 26 	db c_B,c_L,c_O,c_A,c_D, 0 , 0, 11, c_L, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 11,c_NEWLINE   ; "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0753   4348 29 00 00 0B 
0753   434C 31 33 26 32 
0753   4350 2A 1A 26 29 
0753   4354 29 37 0B 76 
0754   4358 27 38 26 3B 	db c_B,c_S,c_A,c_V,c_E, 0 , 0, 11, c_S, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 26, c_L, c_E, c_N,  11,c_NEWLINE   ; "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0754   435C 2A 00 00 0B 
0754   4360 38 33 26 32 
0754   4364 2A 1A 26 29 
0754   4368 29 37 1A 31 
0754   436C 2A 33 0B 76 
0755   4370             ;	db "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0756   4370             ;	db "RENAME",22h,"ROLDNAME NEWNAME",22h,0dh
0757   4370 76              db c_NEWLINE
0758   4371 2E 33 38 39 	db c_I,c_N,c_S,c_T,c_A,c_L,c_L, 0 , c_D,c_R,c_V, 0 ,c_T,c_O, 0, c_R,c_A,c_M,  0, 11, c_I, 0, c_A, c_D, c_D, c_R,  11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0758   4375 26 31 31 00 
0758   4379 29 37 3B 00 
0758   437D 39 34 00 37 
0758   4381 26 32 00 0B 
0758   4385 2E 00 26 29 
0758   4389 29 37 0B 76 
0759   438D             ;	db c_T,c_E,c_S,c_T, 0 , 0 , 0, 11, c_T, c_L, c_T, c_T, c_T, c_0+2, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0760   438D 76              db c_NEWLINE
0761   438E 2D 2A 31 35 	db c_H,c_E,c_L,c_P, 0 , 0 , 0, 11, c_H, 11,c_NEWLINE   ;  c_H,   "HELP  ",22h,"H",22h,0dh
0761   4392 00 00 00 0B 
0761   4396 2D 0B 76 
0762   4399             ;	db "FOR SIGGI'S UFM :V/R/K",0dh
0763   4399 76              db c_NEWLINE
0764   439A FF          	db $ff
0765   439B             
0766   439B             
0767   439B             ; === Subroutine print help text ====
0768   439B             AA08:
0769   439B 21 0F 43    HLP:	LD HL,HLPTXT
0770   439E 7E          HLP1:	LD A,(HL)
0771   439F FE FF       	CP $FF
0772   43A1 28 04       	JR Z, EXITHLP
0773   43A3 D7              RST 10H
0774   43A4 23          	INC HL
0775   43A5 18 F7       	JR HLP1
0776   43A7             EXITHLP:
0777   43A7 01 2A 00        LD   BC,42
0778   43AA AF              XOR  A
0779   43AB C9              RET
0780   43AC             
0781   43AC             
0782   43AC             
0783   43AC             GO_QSAVE_MODE:
0784   43AC CD E7 02    	CALL FAST	; go to fast mode
0785   43AF DB FE           IN      A,($FE)         ; signal to 0 pause    
0786   43B1 06 C8           LD B,200  ; 200=200ms Pause
0787   43B3 C5          W1: push BC
0788   43B4 06 00           ld b,0
0789   43B6             W2:
0790   43B6 10 FE           djnz W2     ; 1 millisec (256*4)
0791   43B8 C1              pop BC
0792   43B9 10 F8           djnz W1
0793   43BB 1E 4B           LD E, 75    ; ID for ZX_SAVE_TAG_QSAVE_START
0794   43BD CD 1F 03        CALL $031F  ; SAVE byte in E
0795   43C0 D3 FF           OUT     ($FF),A         ; ; signal to 1 / syncoff, send hsyncs
0796   43C2 06 00           ld b,0
0797   43C4             W4:
0798   43C4 10 FE           djnz W4     ; 1 millisec (256*4) to go to QSAVE mode
0799   43C6 C9              RET
0800   43C7             
0801   43C7             TRY_HANDSHAKE:  ; See if WESPI responds, return 1 if so, 0 for timeout
0802   43C7             AA30:
0803   43C7 CD AC 43        CALL GO_QSAVE_MODE
0804   43CA 21 04 40        ld   hl, 16388 ; RAMTOP
0805   43CD 06 02           ld   B,2
0806   43CF 0E 5A           ld   C,90 ; packet ID ZX_QSAVE_TAG_HANDSHAKE
0807   43D1             AA31:
0808   43D1 CD 44 44        CALL SEND_PACKET
0809   43D4 06 B5           ld   b,181  ; timeout, 500ms (inner loop 3.15ms)
0810   43D6             HS_LOOP1:
0811   43D6 C5              PUSH BC
0812   43D7 06 00           LD   B,0
0813   43D9             HS_LOOP2:                  ; 35 cycles=10.7us, inner Loop 2.75 millisec
0814   43D9 DB FE           in a,($FE)  ; 11
0815   43DB 17              rla         ; 4
0816   43DC 38 0E           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0817   43DE 10 F9           DJNZ HS_LOOP2 ;13
0818   43E0                 ; re-check here to not have a blind spot for outer loop
0819   43E0 DB FE           in a,($FE)  ; 11
0820   43E2 17              rla         ; 4
0821   43E3 38 07           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0822   43E5 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff in between to not let levels drift (not good for follow-up cmds?)
0823   43E7 C1              POP  BC
0824   43E8 10 EC           DJNZ HS_LOOP1
0825   43EA                 ; no signal found
0826   43EA AF              XOR  A
0827   43EB C9              RET
0828   43EC             
0829   43EC             HS_FOUND
0830   43EC D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0831   43EE                 ; let the output recover with active signal after being low from input. takes about 1ms as seen in oscilloscope
0832   43EE 06 00           LD   B,0
0833   43F0             HS_FINALDELAY: ; 3ms here before next cmd
0834   43F0 7E              LD   A,(HL)
0835   43F1 7E              LD   A,(HL)
0836   43F2 7E              LD   A,(HL)    
0837   43F3 7E              LD   A,(HL)    
0838   43F4 10 FA           DJNZ HS_FINALDELAY
0839   43F6 C1              POP  BC
0840   43F7 3E 01           LD   A,1
0841   43F9 A7              AND  A
0842   43FA C9              RET
0843   43FB             
0844   43FB             QS_FINAL_SZ:
0845   43FB 00              db 0 ; size of return packet to request, use smallest possible
0846   43FC             
0847   43FC             QS_FINAL_ACK:  ; Get info is operation was sussessful (Z) or failed (NZ), USES BC DE HL, A
0848   43FC 21 FB 43        ld   hl, QS_FINAL_SZ ; Requested length
0849   43FF 06 01           ld   B,1
0850   4401 0E 63           LD   C,99 ; packet ID ZX_QSAVE_TAG_END_RQ
0851   4403             AA32:
0852   4403 CD 44 44        CALL SEND_PACKET
0853   4406             
0854   4406                 ; await reply, first byte is tag, then result
0855   4406             AA33:
0856   4406 CD 16 44        CALL QLD_GETBYTE
0857   4409 FE 2A           CP   42 ; tag
0858   440B C0              RET  NZ
0859   440C 06 08           ld B,8  ; 
0860   440E             QSFDLY:
0861   440E 10 0F           djnz lgapdly     ; 13*n-5 = 47 for 4
0862   4410             AA34:
0863   4410 CD 16 44        CALL QLD_GETBYTE
0864   4413 FE 01           CP   1 ; result
0865   4415 C9              RET    ; Z on match
0866   4416             
0867   4416             
0868   4416             
0869   4416             ; gab between byte calls should be 77+12+7 - 17-10 = 69 clocks
0870   4416             
0871   4416             QLD_GETBYTE:    ; uses BC D, result in A
0872   4416 0E FE           ld c,$fe   ; 7
0873   4418 06 08           ld b,8  ; 7    for gap between start and bits
0874   441A             
0875   441A             lwt_stdly:                  ; 25 cycles=7.7us
0876   441A DB FE           in a,($FE)  ; 11
0877   441C 17              rla         ; 4
0878   441D 30 FB           jr nc,lwt_stdly ; 12 / 7  (D7=0 is low level, wait for high)
0879   441F                 ; trigger is seen 4us too late in average, so wait 48-4 - 4 us now: 130 cy in-in
0880   441F             lgapdly:
0881   441F 10 FE           djnz lgapdly     ; 13*n-5 = 99 for 8
0882   4421 06 08           ld b,8  ; 7
0883   4423             lbloop:                 ;  need 104 for 32us
0884   4423 ED 50           in d,(c)    ; 12
0885   4425 CB 12           rl d        ; 8
0886   4427 17              rla         ; 4 (rl a is 8)
0887   4428 16 04           ld d,4      ; 7
0888   442A             lbdly:
0889   442A 15              dec d          ; 4          b*16-5 = 59
0890   442B 20 FD           jr nz,lbdly     ; 12 / 7
0891   442D 10 F4           djnz lbloop     ; 13 / 8
0892   442F C9              RET     
0893   4430                 
0894   4430                 ;ORIGINAL:
0895   4430                 ;ld (hl),a   ; 7
0896   4430             	;CALL UPDATE  ; will use DE, inc HL    77 clks
0897   4430                 ;jr lwt_start     ; 12
0898   4430             
0899   4430             
0900   4430             
0901   4430             
0902   4430             ;*
0903   4430             ;* Evaluate string  start of the string is in HL and the length in BC
0904   4430             ;*
0905   4430 E7          NAME:	RST 20h
0906   4431 CD 55 0F    	CALL 0F55h ; evaluate
0907   4434 3A 01 40    	LD A,(4001h)
0908   4437 87          	ADD A,A
0909   4438 FA 9A 0D    	JP M,0D9Ah  ; error
0910   443B E1          	POP HL
0911   443C D0          	RET NC
0912   443D E5          	PUSH HL
0913   443E CD F8 13    	CALL 13F8h ; get indexvar fom calc stack STK-FETCH
0914   4441                 ; For strings, the start of the string is in DE and the length in BC
0915   4441 62          	LD H,D
0916   4442 6B          	LD L,E
0917   4443 C9          	RET
0918   4444             
0919   4444             
0920   4444             SEND_PACKET: ; HL points to data, C holds type, B lenght (0=256bytes), HL will point behind sent data afterwards
0921   4444 F5              PUSH AF
0922   4445 C5              PUSH BC ; BC needed twice, for header, and recovered at end
0923   4446 C5              PUSH BC
0924   4447             
0925   4447 06 E1           LD B,225    ;   TODO 125 should be enough
0926   4449             SPWT:
0927   4449 10 FE           djnz SPWT     ; 500 microsec  (125*4)  ; let the video lines sync again, require 5 lines (320), some margin added
0928   444B             
0929   444B                 ; we want all our pulses in sync with the HSYNC pulses to not interfere   
0930   444B AF              XOR A       ; make sure A' not at sync or display position to
0931   444C 08              EX AF,AF'   ; just cause short INT on MNI here:
0932   444D                             
0933   444D D3 FE           OUT ($FE),A  ; ENABLE NMI
0934   444F 76              HALT
0935   4450 D3 FD           OUT ($FD),A  ; Disable NMI   from here, start first bit in 54us =174cy
0936   4452 DB FE           IN      A,($FE)         ; signal to 0 /on - syncout
0937   4454 7E              LD   A,(HL)     ; 7 dummy 
0938   4455 00              NOP             ; 4
0939   4456 06 07           LD   B,7
0940   4458 00              NOP             ; timing adjust to have bits symmetrical in (black-shouldered) line
0941   4459 D3 FF           OUT     ($FF),A ;11        ; signal to 1 / syncoff
0942   445B             waitnline:
0943   445B 10 FE           DJNZ waitnline          ; delay for next line 13 per loop ..
0944   445D C1              POP  BC            ;10
0945   445E             
0946   445E             
0947   445E                 ; Send packettype in C
0948   445E             AA35:
0949   445E CD A4 44        CALL SENDNIBBLE ;151, so we need 56 cycles between nibbles to get to 207 for one hsync line
0950   4461             
0951   4461 23              INC  HL         ; 6  ; DUMMY matching later dec
0952   4462 7E              LD   A,(HL)     ; 7 
0953   4463 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0954   4465 7E              LD   A,(HL)     ; 7 
0955   4466 7E              LD   A,(HL)     ; 7 
0956   4467 7E              LD   A,(HL)     ; 7 
0957   4468 7E              LD   A,(HL)     ; 7 
0958   4469 00              NOP
0959   446A             AA36:
0960   446A CD A4 44        CALL SENDNIBBLE ;151
0961   446D             
0962   446D 2B              DEC  HL 
0963   446E 7E              LD   A,(HL)     ; 7 
0964   446F D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0965   4471 7E              LD   A,(HL)     ; 7 
0966   4472 7E              LD   A,(HL)     ; 7 
0967   4473 7E              LD   A,(HL)     ; 7 
0968   4474 7E              LD   A,(HL)     ; 7 
0969   4475 48              LD C,B             ;4
0970   4476             
0971   4476                 ; Send length in B
0972   4476             AA37:
0973   4476 CD A4 44        CALL SENDNIBBLE ;151
0974   4479             
0975   4479 23              INC  HL         ; 6  ; DUMMY matching later dec
0976   447A 7E              LD   A,(HL)     ; 7 
0977   447B D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0978   447D 7E              LD   A,(HL)     ; 7 
0979   447E 7E              LD   A,(HL)     ; 7 
0980   447F 7E              LD   A,(HL)     ; 7 
0981   4480 7E              LD   A,(HL)     ; 7 
0982   4481 00              NOP             ; 4
0983   4482             AA38:
0984   4482 CD A4 44        call SENDNIBBLE ;151
0985   4485             
0986   4485 2B              DEC  HL 
0987   4486 7E              LD   A,(HL)     ; 7 
0988   4487             byteloop:
0989   4487 D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0990   4489 7E              LD   A,(HL)     ; 7 
0991   448A 7E              LD   A,(HL)     ; 7 
0992   448B 7E              LD   A,(HL)     ; 7 
0993   448C 4E              LD   C,(HL)     ; 7 
0994   448D 00              NOP
0995   448E             AA39:
0996   448E CD A4 44        call SENDNIBBLE ;151
0997   4491 23              INC  HL         ; 6
0998   4492 7E              LD   A,(HL)     ; 7 
0999   4493 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1000   4495 7E              LD   A,(HL)     ; 7 
1001   4496 7E              LD   A,(HL)     ; 7 
1002   4497 7E              LD   A,(HL)     ; 7 
1003   4498 7E              LD   A,(HL)     ; 7 
1004   4499 00              NOP
1005   449A                                 ; 56
1006   449A             AA40:    
1007   449A CD A4 44        CALL SENDNIBBLE ;151
1008   449D 10 E8           DJNZ byteloop   ; 13
1009   449F D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
1010   44A1             
1011   44A1 C1              POP  BC
1012   44A2 F1              POP  AF
1013   44A3 C9              ret
1014   44A4             
1015   44A4             
1016   44A4             SENDNIBBLE: ;31 per bit, 134 incl RET 151 incl call, nibble in C lower half
1017   44A4                 ; Four bits to send
1018   44A4                 ;# bit 1 start
1019   44A4 CB 01           RLC C       ; 8
1020   44A6 38 19           JR C, csendH1 ; 12/7
1021   44A8 D8              ret c        ; 11/5 dummy for symmetric timing
1022   44A9                 ;# bit 1 send 0
1023   44A9 DB FE           IN      A,($FE)         ; signal to 0 /on
1024   44AB             
1025   44AB                 ;# bit 2 start
1026   44AB CB 01           RLC C       ; 8
1027   44AD 38 2A           JR C, csendH2 ; 12/7
1028   44AF D8              ret c        ; 11/5 dummy for symmetric timing
1029   44B0                 ;# bit 2 send 0
1030   44B0 DB FE           IN      A,($FE)         ; signal to 0 /on
1031   44B2             
1032   44B2                 ;# bit 3 start
1033   44B2 CB 01           RLC C       ; 8
1034   44B4 38 34           JR C, csendH3 ; 12/7
1035   44B6 D8              ret c        ; 11/5 dummy for symmetric timing
1036   44B7                 ;# bit 3 send 0
1037   44B7 DB FE           IN      A,($FE)         ; signal to 0 /on
1038   44B9             
1039   44B9                 ;# bit 4 start
1040   44B9 CB 01           RLC C       ; 8
1041   44BB 38 37           JR C, csendH4 ; 12/7
1042   44BD D8              ret c        ; 11/5 dummy for symmetric timing
1043   44BE                 ;# bit 4 send 0
1044   44BE DB FE           IN      A,($FE)         ; signal to 0 /on
1045   44C0             
1046   44C0 C9              ret
1047   44C1             
1048   44C1             
1049   44C1             csendH1:    ;# bit 1 send 1
1050   44C1 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1051   44C3             
1052   44C3                 ;# bit 2 start
1053   44C3 CB 01           RLC C       ; 8
1054   44C5 38 12           JR C, csendH2 ; 12/7
1055   44C7 D8              ret c        ; 11/5 dummy for symmetric timing
1056   44C8                 ;# bit 2 send 0
1057   44C8 DB FE           IN      A,($FE)         ; signal to 0 /on
1058   44CA             
1059   44CA                 ;# bit 3 start
1060   44CA CB 01           RLC C       ; 8
1061   44CC 38 1C           JR C, csendH3 ; 12/7
1062   44CE D8              ret c        ; 11/5 dummy for symmetric timing
1063   44CF                 ;# bit 3 send 0
1064   44CF DB FE           IN      A,($FE)         ; signal to 0 /on
1065   44D1             
1066   44D1                 ;# bit 4 start
1067   44D1 CB 01           RLC C       ; 8
1068   44D3 38 1F           JR C, csendH4 ; 12/7
1069   44D5 D8              ret c        ; 11/5 dummy for symmetric timing
1070   44D6                 ;# bit 4 send 0
1071   44D6 DB FE           IN      A,($FE)         ; signal to 0 /on
1072   44D8 C9              ret
1073   44D9             
1074   44D9             csendH2:    ;# bit 2 send 1
1075   44D9 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1076   44DB             
1077   44DB                 ;# bit 3 start
1078   44DB CB 01           RLC C       ; 8
1079   44DD 38 0B           JR C, csendH3 ; 12/7
1080   44DF D8              ret c        ; 11/5 dummy for symmetric timing
1081   44E0                 ;# bit 3 send 0
1082   44E0 DB FE           IN      A,($FE)         ; signal to 0 /on
1083   44E2             
1084   44E2                 ;# bit 4 start
1085   44E2 CB 01           RLC C       ; 8
1086   44E4 38 0E           JR C, csendH4 ; 12/7
1087   44E6 D8              ret c        ; 11/5 dummy for symmetric timing
1088   44E7                 ;# bit 4 send 0
1089   44E7 DB FE           IN      A,($FE)         ; signal to 0 /on
1090   44E9 C9              ret
1091   44EA             
1092   44EA             csendH3:    ;# bit 3 send 1
1093   44EA D3 FF           OUT     ($FF),A         ; signal to 1 /off
1094   44EC             
1095   44EC                 ;# bit 4 start
1096   44EC CB 01           RLC C       ; 8
1097   44EE 38 04           JR C, csendH4 ; 12/7
1098   44F0 D8              ret c        ; 11/5 dummy for symmetric timing
1099   44F1                 ;# bit 4 send 0
1100   44F1 DB FE           IN      A,($FE)         ; signal to 0 /on
1101   44F3 C9              ret
1102   44F4             
1103   44F4             csendH4:    ;# bit 4 send 1
1104   44F4 D3 FF           OUT     ($FF),A         ; signal to 1 /off
1105   44F6 C9              ret
1106   44F7             
1107   44F7             DRIVER_END:
1108   44F7             
1109   44F7 76             db $76   ;N/L 
1110   44F8             
1111   44F8             line10:
1112   44F8 00 0A          db 0,10  ;line number 
1113   44FA 13 00          dw dfile-$-2  ;line length 
1114   44FC F5             db $f5   ;PRINT 
1115   44FD D4             db $d4   ;USR 
1116   44FE 1D             db $1d   ;1 
1117   44FF 22             db $22   ;6 
1118   4500 21             db $21   ;5 
1119   4501 1D             db $1d   ;1 
1120   4502 20             db $20   ;4 
1121   4503 7E             db $7e   ;FP mark 
1122   4504 8F             db $8f   ;5 bytes FP number 
1123   4505 01             db $01   ; 
1124   4506 04             db $04   ; 
1125   4507 00             db $00   ; 
1126   4508 00             db $00   ; 
1127   4509 1A             db $1a   ; ,
1128   450A 0B             db $0b   ; "
1129   450B 2D             db c_H   ; Help
1130   450C               
1131   450C              ;  db c_I   ; I 10000 install
1132   450C                ;db c_I   ; TTTT2 = QLOAD test
1133   450C                ;db c_T   ; SNNN = dummy save for testing
1134   450C                ;db c_S   ; STST,1024,100 binsave
1135   450C                ;db c_T   ; LTST,1024   binload
1136   450C              ;  db 0   ; 
1137   450C              ;  db c_0+1   ; 
1138   450C              ;  db c_0+0   ; 
1139   450C              ;  db c_0+0   ; 
1140   450C              ;  db c_0+0   ; 
1141   450C              ;  db c_0+0   ; 
1142   450C             ;   db 26
1143   450C             ;   db c_0+1   ; 
1144   450C             ;   db c_0+0   ; 
1145   450C             ;   db c_0+0   ; 
1146   450C 0B             db $0b   ; "
1147   450D 76             db $76   ;N/L 
1148   450E 76             db $76   ;N/L 
1149   450F             
1150   450F             
1151   450F                
1152   450F             ;- Display file -------------------------------------------- 
1153   450F              
1154   450F             dfile: 
1155   450F 76             db $76 
1156   4510 3F 3D          db c_Z,c_X,
1157   4512 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1157   4516 76 76 76 76 
1158   451A 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1158   451E 76 76 76 76 
1159   4522 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
1159   4526 76 76 76 76 
1160   452A              
1161   452A             ;- BASIC-Variables ---------------------------------------- 
1162   452A              
1163   452A             var: 
1164   452A 80             db $80 
1165   452B              
1166   452B             ;- End of program area ---------------------------- 
1167   452B             
1168   452B             last: 
1169   452B              
1170   452B                end 
tasm: Number of errors = 0
